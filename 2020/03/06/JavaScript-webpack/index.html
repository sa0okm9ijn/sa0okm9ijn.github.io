
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  
    <title>JavaScript-webpack | 110laile</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="110laile">
    

    
    <meta name="description" content="浏览器模块化带来的问题 效率问题：精细的模块划分带来了更多的JS文件，更多的JS文件带来了更多的请求，降低了页面访问效率 兼容性问题：浏览器目前仅支持ES6的模块化标准，并且还存在兼容性问题 工具问题：浏览器不支持npm下载的第三方包  这些仅仅是前端工程化的一个缩影 当开发一个具有规模的程序，你将遇到非常多的非业务问题，这些问题包括：执行效率、兼容性、代码的可维护性可扩展性、团队协作、测试等等等">
<meta name="keywords" content="JavaScript,webpack">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript-webpack">
<meta property="og:url" content="http://yoursite.com/2020/03/06/JavaScript-webpack/index.html">
<meta property="og:site_name" content="110laile">
<meta property="og:description" content="浏览器模块化带来的问题 效率问题：精细的模块划分带来了更多的JS文件，更多的JS文件带来了更多的请求，降低了页面访问效率 兼容性问题：浏览器目前仅支持ES6的模块化标准，并且还存在兼容性问题 工具问题：浏览器不支持npm下载的第三方包  这些仅仅是前端工程化的一个缩影 当开发一个具有规模的程序，你将遇到非常多的非业务问题，这些问题包括：执行效率、兼容性、代码的可维护性可扩展性、团队协作、测试等等等">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-07-05-06-11.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-07-07-50-09.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-07-07-53-45.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-07-07-54-25.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-07-07-55-54.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-09-10-26-15.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-09-10-53-28.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-09-11-54-08.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-09-12-32-38.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-09-12-35-05.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-09-12-39-16.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-09-12-43-52.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-09-12-47-43.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-09-12-54-34.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-09-15-51-07.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-09-12-32-38.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-08-16-38-26.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-08-16-58-06.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-08-17-01-13.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-09-15-51-07.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-10-12-00-28.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-10-12-38-03.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-10-12-44-13.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-13-10-39-24.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-13-09-28-52.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-13-09-29-08.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-13-09-35-44.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-13-10-29-54.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-15-12-45-16.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-15-12-49-26.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-31-13-54-37.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-31-14-00-56.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-31-14-04-11.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-31-14-08-49.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-02-03-11-48-45.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-02-03-11-50-05.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-02-04-14-31-33.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-02-04-14-37-51.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/postcss-workflow.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/assets/2020-02-05-14-37-11.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-02-07-10-12-01.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-02-07-10-25-56.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-02-07-10-27-30.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-02-12-09-53-01.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-02-13-16-26-41.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-02-13-16-28-10.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-02-21-13-32-36.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-02-21-14-20-49.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-02-21-14-22-32.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-02-21-14-34-05.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-02-24-13-24-57.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-02-24-17-19-47.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/160bfdcf2a31ce4a">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-02-28-15-37-26.png">
<meta property="og:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-02-28-15-41-44.png">
<meta property="og:updated_time" content="2020-03-26T08:48:00.896Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript-webpack">
<meta name="twitter:description" content="浏览器模块化带来的问题 效率问题：精细的模块划分带来了更多的JS文件，更多的JS文件带来了更多的请求，降低了页面访问效率 兼容性问题：浏览器目前仅支持ES6的模块化标准，并且还存在兼容性问题 工具问题：浏览器不支持npm下载的第三方包  这些仅仅是前端工程化的一个缩影 当开发一个具有规模的程序，你将遇到非常多的非业务问题，这些问题包括：执行效率、兼容性、代码的可维护性可扩展性、团队协作、测试等等等">
<meta name="twitter:image" content="http://yoursite.com/2020/03/06/JavaScript-webpack/2020-01-07-05-06-11.png">

    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="110laile" title="110laile"></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="110laile">110laile</a></h1>
				<h2 class="blog-motto">个人技术博客</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索">
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</ul></nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/03/06/JavaScript-webpack/" title="JavaScript-webpack" itemprop="url">JavaScript-webpack</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="110laile" target="_blank" itemprop="author">110laile</a>
		
  </p><p class="article-time">
    <time datetime="2020-03-06T02:19:44.000Z" itemprop="datePublished"> 发表于 2020-03-06</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器模块化带来的问题"><span class="toc-number">1.</span> <span class="toc-text">浏览器模块化带来的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#根本原因"><span class="toc-number">1.1.</span> <span class="toc-text">根本原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决办法"><span class="toc-number">1.2.</span> <span class="toc-text">解决办法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见的构建工具"><span class="toc-number">2.</span> <span class="toc-text">常见的构建工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack核心"><span class="toc-number">3.</span> <span class="toc-text">webpack核心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#安装"><span class="toc-number">3.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用"><span class="toc-number">3.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模块化兼容性"><span class="toc-number">3.3.</span> <span class="toc-text">模块化兼容性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编译结果分析"><span class="toc-number">3.4.</span> <span class="toc-text">编译结果分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编译过程"><span class="toc-number">3.5.</span> <span class="toc-text">编译过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化"><span class="toc-number">3.5.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编译"><span class="toc-number">3.5.2.</span> <span class="toc-text">编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#输出"><span class="toc-number">3.5.3.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总过程"><span class="toc-number">3.5.4.</span> <span class="toc-text">总过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置文件"><span class="toc-number">3.6.</span> <span class="toc-text">配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mode配置"><span class="toc-number">3.6.1.</span> <span class="toc-text">mode配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#devtool配置"><span class="toc-number">3.6.2.</span> <span class="toc-text">devtool配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#入口和出口"><span class="toc-number">3.6.3.</span> <span class="toc-text">入口和出口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#loader"><span class="toc-number">3.6.4.</span> <span class="toc-text">loader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#plugin"><span class="toc-number">3.6.5.</span> <span class="toc-text">plugin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他细节配置"><span class="toc-number">3.6.6.</span> <span class="toc-text">其他细节配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用扩展"><span class="toc-number">3.7.</span> <span class="toc-text">常用扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack内置插件"><span class="toc-number">3.8.</span> <span class="toc-text">webpack内置插件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css工程化"><span class="toc-number">4.</span> <span class="toc-text">css工程化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#css工程化概述"><span class="toc-number">4.1.</span> <span class="toc-text">css工程化概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#css的问题"><span class="toc-number">4.1.1.</span> <span class="toc-text">css的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何解决"><span class="toc-number">4.1.2.</span> <span class="toc-text">如何解决</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用webapck拆分css"><span class="toc-number">4.2.</span> <span class="toc-text">利用webapck拆分css</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BEM-解决类名冲突"><span class="toc-number">4.3.</span> <span class="toc-text">BEM(解决类名冲突)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css-in-js-解决类名冲突"><span class="toc-number">4.4.</span> <span class="toc-text">css in js(解决类名冲突)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css-module-解决类名冲突问题"><span class="toc-number">4.5.</span> <span class="toc-text">css module(解决类名冲突问题)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#预编译器less-解决重复样式问题"><span class="toc-number">4.6.</span> <span class="toc-text">预编译器less(解决重复样式问题)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PostCss"><span class="toc-number">4.7.</span> <span class="toc-text">PostCss</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽离css文件"><span class="toc-number">4.8.</span> <span class="toc-text">抽离css文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js兼容性"><span class="toc-number">5.</span> <span class="toc-text">js兼容性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#babel的安装和使用"><span class="toc-number">5.1.</span> <span class="toc-text">babel的安装和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#babel简介"><span class="toc-number">5.1.1.</span> <span class="toc-text">babel简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babel的安装"><span class="toc-number">5.1.2.</span> <span class="toc-text">babel的安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babel的使用"><span class="toc-number">5.1.3.</span> <span class="toc-text">babel的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babel的配置"><span class="toc-number">5.1.4.</span> <span class="toc-text">babel的配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#babel预设"><span class="toc-number">5.2.</span> <span class="toc-text">babel预设</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#babel插件"><span class="toc-number">5.3.</span> <span class="toc-text">babel插件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#babel-plugin-proposal-class-properties"><span class="toc-number">5.3.1.</span> <span class="toc-text">@babel/plugin-proposal-class-properties</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babel-plugin-proposal-function-bind"><span class="toc-number">5.3.2.</span> <span class="toc-text">@babel/plugin-proposal-function-bind</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babel-plugin-proposal-optional-chaining"><span class="toc-number">5.3.3.</span> <span class="toc-text">@babel/plugin-proposal-optional-chaining</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babel-plugin-transform-remove-console"><span class="toc-number">5.3.4.</span> <span class="toc-text">babel-plugin-transform-remove-console</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babel-plugin-transform-runtime"><span class="toc-number">5.3.5.</span> <span class="toc-text">@babel/plugin-transform-runtime</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能优化"><span class="toc-number">6.</span> <span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#性能优化概述"><span class="toc-number">6.1.</span> <span class="toc-text">性能优化概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#减少模块解析-构建"><span class="toc-number">6.2.</span> <span class="toc-text">减少模块解析(构建)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优化loader性能-构建"><span class="toc-number">6.3.</span> <span class="toc-text">优化loader性能(构建)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#热替换-HMR-构建"><span class="toc-number">6.4.</span> <span class="toc-text">热替换 HMR(构建)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用和原理"><span class="toc-number">6.4.1.</span> <span class="toc-text">使用和原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#样式热替换"><span class="toc-number">6.4.2.</span> <span class="toc-text">样式热替换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#手动分包-传输"><span class="toc-number">6.5.</span> <span class="toc-text">手动分包(传输)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本原理"><span class="toc-number">6.5.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#打包公共模块"><span class="toc-number">6.5.2.</span> <span class="toc-text">打包公共模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用公共模块"><span class="toc-number">6.5.3.</span> <span class="toc-text">使用公共模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">6.5.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动分包-传输"><span class="toc-number">6.6.</span> <span class="toc-text">自动分包(传输)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本原理-1"><span class="toc-number">6.6.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分包策略的基本配置"><span class="toc-number">6.6.2.</span> <span class="toc-text">分包策略的基本配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分包策略的其他配置"><span class="toc-number">6.6.3.</span> <span class="toc-text">分包策略的其他配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缓存组"><span class="toc-number">6.6.4.</span> <span class="toc-text">缓存组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配合多页应用"><span class="toc-number">6.6.5.</span> <span class="toc-text">配合多页应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原理"><span class="toc-number">6.6.6.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码压缩-传输"><span class="toc-number">6.7.</span> <span class="toc-text">代码压缩(传输)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#前言"><span class="toc-number">6.7.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Terser"><span class="toc-number">6.7.2.</span> <span class="toc-text">Terser</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webpack-Terser"><span class="toc-number">6.7.3.</span> <span class="toc-text">webpack+Terser</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tree-shaking-传输"><span class="toc-number">6.8.</span> <span class="toc-text">tree shaking(传输)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#背景"><span class="toc-number">6.8.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用-1"><span class="toc-number">6.8.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原理-1"><span class="toc-number">6.8.3.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用第三方库"><span class="toc-number">6.8.4.</span> <span class="toc-text">使用第三方库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#作用域分析"><span class="toc-number">6.8.5.</span> <span class="toc-text">作用域分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#副作用问题"><span class="toc-number">6.8.6.</span> <span class="toc-text">副作用问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css-tree-shaking"><span class="toc-number">6.8.7.</span> <span class="toc-text">css tree shaking</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ESLint-代码风格"><span class="toc-number">6.9.</span> <span class="toc-text">ESLint(代码风格)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用-2"><span class="toc-number">6.9.1.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置"><span class="toc-number">6.9.2.</span> <span class="toc-text">配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#懒加载（传输）"><span class="toc-number">6.10.</span> <span class="toc-text">懒加载（传输）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bundle-analyzer-budle分析"><span class="toc-number">6.11.</span> <span class="toc-text">bundle analyzer(budle分析)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gzip-传输"><span class="toc-number">6.12.</span> <span class="toc-text">gzip(传输)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#B-S结构中的压缩传输"><span class="toc-number">6.12.1.</span> <span class="toc-text">B/S结构中的压缩传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用webpack进行预压缩"><span class="toc-number">6.12.2.</span> <span class="toc-text">使用webpack进行预压缩</span></a></li></ol></li></ol></li></ol>
		
		</div>
		
		<h2 id="浏览器模块化带来的问题"><a href="#浏览器模块化带来的问题" class="headerlink" title="浏览器模块化带来的问题"></a>浏览器模块化带来的问题</h2><ul>
<li>效率问题：精细的模块划分带来了更多的JS文件，更多的JS文件带来了更多的请求，降低了页面访问效率</li>
<li>兼容性问题：浏览器目前仅支持ES6的模块化标准，并且还存在兼容性问题</li>
<li>工具问题：浏览器不支持npm下载的第三方包</li>
</ul>
<p>这些仅仅是前端工程化的一个缩影</p>
<p>当开发一个具有规模的程序，你将遇到非常多的非业务问题，这些问题包括：执行效率、兼容性、代码的可维护性可扩展性、团队协作、测试等等等等，我们将这些问题称之为工程问题。工程问题与业务无关，但它深刻的影响到开发进度，如果没有一个好的工具解决这些问题，将使得开发进度变得极其缓慢，同时也让开发者陷入技术的泥潭。</p>
<h3 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h3><p>思考：上面提到的问题，为什么在node端没有那么明显，反而到了浏览器端变得如此严重呢？</p>
<p>答：在node端，运行的JS文件在本地，因此可以本地读取文件，它的效率比浏览器远程传输文件高的多</p>
<p><strong>根本原因</strong>：在浏览器端，开发时态（devtime）和运行时态（runtime）的侧重点不一样</p>
<p><strong>开发时态，devtime：</strong></p>
<ol>
<li>模块划分越细越好</li>
<li>支持多种模块化标准</li>
<li>支持npm或其他包管理器下载的模块</li>
<li>能够解决其他工程化的问题</li>
</ol>
<p><strong>运行时态，runtime：</strong></p>
<ol>
<li>文件越少越好</li>
<li>文件体积越小越好</li>
<li>代码内容越乱越好</li>
<li>所有浏览器都要兼容</li>
<li>能够解决其他运行时的问题，主要是执行效率问题</li>
</ol>
<p>这种差异在小项目中表现的并不明显，可是一旦项目形成规模，就越来越明显，如果不解决这些问题，前端项目形成规模只能是空谈</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>既然开发时态和运行时态面临的局面有巨大的差异，因此，我们需要有一个工具，这个工具能够让开发者专心的在开发时态写代码，然后利用这个工具将开发时态编写的代码转换为运行时态需要的东西。</p>
<p>这样的工具，叫做构建工具</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-07-05-06-11.png" alt></p>
<p>这样一来，开发者就可以专注于开发时态的代码结构，而不用担心运行时态遇到的问题了。</p>
<h2 id="常见的构建工具"><a href="#常见的构建工具" class="headerlink" title="常见的构建工具"></a>常见的构建工具</h2><ul>
<li>webpack</li>
<li>grunt</li>
<li>gulp</li>
<li>browserify</li>
<li>fis</li>
<li>其他</li>
</ul>
<h2 id="webpack核心"><a href="#webpack核心" class="headerlink" title="webpack核心"></a>webpack核心</h2><blockquote>
<p>webpack官网：<a href="https://www.webpackjs.com/" target="_blank" rel="noopener">https://www.webpackjs.com/</a></p>
</blockquote>
<p>webpack是基于模块化的打包（构建）工具，它把一切视为模块</p>
<p>它通过一个开发时态的入口模块为起点，分析出所有的依赖关系，然后经过一系列的过程（压缩、合并），最终生成运行时态的文件。</p>
<p>特点:</p>
<ul>
<li><strong>为前端工程化而生</strong>：webpack致力于解决前端工程化，特别是浏览器端工程化中遇到的问题，让开发者集中注意力编写业务代码，而把工程化过程中的问题全部交给webpack来处理</li>
<li><strong>简单易用</strong>：支持零配置，可以不用写任何一行额外的代码就使用webpack</li>
<li><strong>强大的生态</strong>：webpack是非常灵活、可以扩展的，webpack本身的功能并不多，但它提供了一些可以扩展其功能的机制，使得一些第三方库可以融于到webpack中</li>
<li><strong>基于nodejs</strong>：由于webpack在构建的过程中需要读取文件，因此它是运行在node环境中的</li>
<li><strong>基于模块化</strong>：webpack在构建过程中要分析依赖关系，方式是通过模块化导入语句进行分析的，它支持各种模块化标准，包括但不限于CommonJS、ES6 Module</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>webpack通过npm安装，它提供了两个包：</p>
<ul>
<li>webpack：核心包，包含了webpack构建过程中要用到的所有api</li>
<li>webpack-cli：提供一个简单的cli命令，它调用了webpack核心包的api，来完成构建过程</li>
</ul>
<p>安装方式：</p>
<ul>
<li>全局安装：可以全局使用webpack命令，但是无法为不同项目对应不同的webpack版本</li>
<li><strong>本地安装</strong>：推荐，每个项目都使用自己的webpack版本进行构建</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack</span><br></pre></td></tr></table></figure>
<p>默认情况下，webpack会以<code>./src/index.js</code>作为入口文件分析依赖关系，打包到<code>./dist/main.js</code>文件中</p>
<p>通过–mode选项可以控制webpack的打包结果的运行环境</p>
<h3 id="模块化兼容性"><a href="#模块化兼容性" class="headerlink" title="模块化兼容性"></a>模块化兼容性</h3><p>由于webpack同时支持CommonJS和ES6 module，因此需要理解它们互操作时webpack是如何处理的</p>
<ul>
<li>同模块化标准<br>如果导出和导入使用的是同一种模块化标准，打包后的效果和之前学习的模块化没有任何差异<br><img src="/2020/03/06/JavaScript-webpack/2020-01-07-07-50-09.png" alt></li>
</ul>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-07-07-53-45.png" alt></p>
<ul>
<li>不同模块化标准<br>不同的模块化标准，webpack按照如下的方式处理<br><img src="/2020/03/06/JavaScript-webpack/2020-01-07-07-54-25.png" alt></li>
</ul>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-07-07-55-54.png" alt></p>
<ul>
<li>最佳实践<br>代码编写最忌讳的是精神分裂，选择一个合适的模块化标准，然后贯彻整个开发阶段。</li>
</ul>
<h3 id="编译结果分析"><a href="#编译结果分析" class="headerlink" title="编译结果分析"></a>编译结果分析</h3><p>基本环境和目录已经建好.我们在src下面添加<code>a.js</code>和<code>index.js</code><br><code>a.js</code>内容<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"module a"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports=<span class="string">"a"</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>index.js</code>内容<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'index module'</span>);</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure></p>
<p><code>index.js</code>为我们的入口文件.我们就上面两个js进行构建打包.首先我们自己按照自己的想法合并上述两个文件.</p>
<ol>
<li><p>首先分析依赖项直到<code>index.js</code>依赖<code>a.js</code>,我们先用对象的方式列出所有依赖,导入模块其实就是执行,所以我们把我们的代码放到一个函数中.至于用到的对象和方法,我们先当参数传进来.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">    <span class="string">"./src/a.js"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module,exports</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"module a"</span>);</span><br><span class="line">        <span class="built_in">module</span>.exports = <span class="string">"a"</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"./src/index.js"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module,exports,require</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'index module'</span>);</span><br><span class="line">        <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块化里是不能污染全局变量的,这里我们声明了module,换个思路,入口文件是直接执行的,我们这里直接用立即执行函数</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">""</span>)</span><br><span class="line">&#125;)(&#123;</span><br><span class="line">    <span class="string">"./src/a.js"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module,exports</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"module a"</span>);</span><br><span class="line">        <span class="built_in">module</span>.exports = <span class="string">"a"</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"./src/index.js"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module,exports,require</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'index module'</span>);</span><br><span class="line">        <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样就不污染全局变量了</p>
<ol start="3">
<li>下面我们来实现合并的代码</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> func = modules[moduleId];</span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">            exports: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        func(<span class="built_in">module</span>, <span class="built_in">module</span>.exports, <span class="built_in">require</span>);</span><br><span class="line">        <span class="keyword">var</span> result = <span class="built_in">module</span>.exports;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">"./src/index.js"</span>); <span class="comment">//require函数相当于是运行一个模块，得到模块导出结果</span></span><br><span class="line">&#125;)(&#123;</span><br><span class="line">    <span class="string">"./src/a.js"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"module a"</span>);</span><br><span class="line">        <span class="built_in">module</span>.exports = <span class="string">"a"</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"./src/index.js"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'index module'</span>);</span><br><span class="line">        <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./src/a.js'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>引入到html中测试,没问题成功…</p>
<ol start="4">
<li>node中还有个缓存什么的机制,我们再来实现以下</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> moduleExports = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (moduleExports[moduleId]) &#123;</span><br><span class="line">            <span class="keyword">return</span> moduleExports[moduleId];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> func = modules[moduleId];</span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">            exports: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        func(<span class="built_in">module</span>, <span class="built_in">module</span>.exports, <span class="built_in">require</span>);</span><br><span class="line">        <span class="keyword">var</span> result = <span class="built_in">module</span>.exports;</span><br><span class="line">        moduleExports[moduleId] = result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">"./src/index.js"</span>); <span class="comment">//require函数相当于是运行一个模块，得到模块导出结果</span></span><br><span class="line">&#125;)(&#123;</span><br><span class="line">    <span class="string">"./src/a.js"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"module a"</span>);</span><br><span class="line">        <span class="built_in">module</span>.exports = <span class="string">"a"</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"./src/index.js"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'index module'</span>);</span><br><span class="line">        <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./src/a.js'</span>);</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./src/a.js'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>引入两次<code>a.js</code>,只执行了一次.</p>
<p>对<code>webpack</code>构建的代码进行整理如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line">  <span class="comment">// The module cache</span></span><br><span class="line">  <span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line">  <span class="comment">// The require function</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Check if module is in cache</span></span><br><span class="line">    <span class="keyword">if</span> (installedModules[moduleId]) &#123;</span><br><span class="line">      <span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line">      i: moduleId,</span><br><span class="line">      l: <span class="literal">false</span>,</span><br><span class="line">      exports: &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// Execute the module function</span></span><br><span class="line">    modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line">    <span class="comment">// Flag the module as loaded</span></span><br><span class="line">    <span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// Return the exports of the module</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Load entry module and return exports</span></span><br><span class="line">  <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="string">"./src/index.js"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/***/</span></span><br><span class="line">  <span class="string">"./src/a.js"</span>:</span><br><span class="line"></span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">eval</span>(<span class="string">"console.log(\"module a\");\r\n\r\nmodule.exports=\"a\";\n\n//# sourceURL=webpack:///./src/a.js?"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="string">"./src/index.js"</span>: (<span class="function"><span class="keyword">function</span> (<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">"console.log('index module');\r\nvar a = __webpack_require__(/*! ./a */ \"./src/a.js\");\r\nconsole.log(a);\r\n\n\n//# sourceURL=webpack:///./src/index.js?"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>对比看来思路完全没问题,不过源码的缓存存储方式有些不同,我们这里就不深挖了,我们这里说下源码中的eval,这里主要还是为了在浏览器调试方便.加上这个之后报错我们可以很好的定位问题所在。具体我们可以对比下用eval和不用eval报错的时候的浏览器的错误.我们也改成eval<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"./src/a.js"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">"console.log(\"module a\");\nmodule.exports = \"a\";"</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"./src/index.js"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">" console.log('index module');\nvar a = require('./src/a.js');\nvar b = require('./src/a.js');b.func();\nconsole.log(a);"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们给b调用一个不存在的方法,看看报错信息,可是这时候还不能具体直到哪个模块报了错,我们在加<code>//# sourceURL=webpack:///./src/a.js&quot;</code> 就可以具体直到哪报错了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"./src/a.js"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">"console.log(\"module a\");\nmodule.exports = \"a\";//# sourceURL=webpack:///./src/a.js"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"./src/index.js"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">" console.log('index module');\nvar a = require('./src/a.js');\nvar b = require('./src/a.js');b.func();\nconsole.log(a);//# sourceURL=webpack:///./src/index.js"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>搞定.</p>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>webpack 的作用是将源代码编译（构建、打包）成最终代码<br><img src="/2020/03/06/JavaScript-webpack/2020-01-09-10-26-15.png" alt></p>
<p>整个过程大致分为三个步骤</p>
<ol>
<li>初始化</li>
<li>编译</li>
<li>输出</li>
</ol>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-09-10-53-28.png" alt></p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>此阶段，webpack会将<strong>CLI参数</strong>、<strong>配置文件</strong>、<strong>默认配置</strong>进行融合，形成一个最终的配置对象。</p>
<p>对配置的处理过程是依托一个第三方库<code>yargs</code>完成的</p>
<p>此阶段相对比较简单，主要是为接下来的编译阶段做必要的准备</p>
<p>目前，可以简单的理解为，初始化阶段主要用于产生一个最终的配置</p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><ol>
<li><strong>创建chunk</strong></li>
</ol>
<p>chunk是webpack在内部构建过程中的一个概念，译为<code>块</code>，它表示通过某个入口找到的所有依赖的统称。</p>
<p>根据入口模块（默认为<code>./src/index.js</code>）创建一个chunk</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-09-11-54-08.png" alt></p>
<p>每个chunk都有至少两个属性：</p>
<ul>
<li>name：默认为main</li>
<li>id：唯一编号，开发环境和name相同，生产环境是一个数字，从0开始</li>
</ul>
<ol start="2">
<li><strong>构建所有依赖模块</strong></li>
</ol>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-09-12-32-38.png" alt></p>
<blockquote>
<p>AST在线测试工具：<a href="https://astexplorer.net/" target="_blank" rel="noopener">https://astexplorer.net/</a></p>
</blockquote>
<p>简图</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-09-12-35-05.png" alt></p>
<ol start="3">
<li><strong>产生chunk assets</strong></li>
</ol>
<p>在第二步完成后，chunk中会产生一个模块列表，列表中包含了<strong>模块id</strong>和<strong>模块转换后的代码</strong></p>
<p>接下来，webpack会根据配置为chunk生成一个资源列表，即<code>chunk assets</code>，资源列表可以理解为是生成到最终文件的文件名和文件内容</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-09-12-39-16.png" alt></p>
<blockquote>
<p>chunk hash是根据所有chunk assets的内容生成的一个hash字符串<br>hash：一种算法，具体有很多分类，特点是将一个任意长度的字符串转换为一个固定长度的字符串，而且可以保证原始内容不变，产生的hash字符串就不变</p>
</blockquote>
<p>简图</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-09-12-43-52.png" alt></p>
<ol>
<li><strong>合并chunk assets</strong></li>
</ol>
<p>将多个chunk的assets合并到一起，并产生一个总的hash</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-09-12-47-43.png" alt></p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>此步骤非常简单，webpack将利用node中的fs模块（文件处理模块），根据编译产生的总的assets，生成相应的文件。</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-09-12-54-34.png" alt></p>
<h4 id="总过程"><a href="#总过程" class="headerlink" title="总过程"></a>总过程</h4><p><img src="/2020/03/06/JavaScript-webpack/2020-01-09-15-51-07.png" alt></p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-09-12-32-38.png" alt></p>
<p><strong>涉及术语</strong></p>
<ol>
<li>module：模块，分割的代码单元，webpack中的模块可以是任何内容的文件，不仅限于JS</li>
<li>chunk：webpack内部构建模块的块，一个chunk中包含多个模块，这些模块是从入口模块通过依赖分析得来的</li>
<li>bundle：chunk构建好模块后会生成chunk的资源清单，清单中的每一项就是一个bundle，可以认为bundle就是最终生成的文件</li>
<li>hash：最终的资源清单所有内容联合生成的hash值</li>
<li>chunkhash：chunk生成的资源清单内容联合生成的hash值</li>
<li>chunkname：chunk的名称，如果没有配置则使用main</li>
<li>id：通常指chunk的唯一编号，如果在开发环境下构建，和chunkname相同；如果是生产环境下构建，则使用一个从0开始的数字进行编号</li>
</ol>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>webpack提供的cli支持很多的参数，例如<code>--mode</code>，但更多的时候，我们会使用更加灵活的配置文件来控制webpack的行为</p>
<p>默认情况下，webpack会读取<code>webpack.config.js</code>文件作为配置文件，但也可以通过CLI参数<code>--config</code>来指定某个配置文件</p>
<p>配置文件中通过CommonJS模块导出一个对象，对象中的各种属性对应不同的webpack配置</p>
<p><strong>注意：配置文件中的代码，必须是有效的node代码</strong></p>
<p>当命令行参数与配置文件中的配置出现冲突时，以命令行参数为准。</p>
<p>有些时候，我们需要针对生产环境和开发环境分别书写webpack配置</p>
<p>为了更好的适应这种要求，webpack允许配置不仅可以是一个对象，还可以是一个<strong>函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">env</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">//配置内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在开始构建时，webpack如果发现配置是一个函数，会调用该函数，将函数返回的对象作为配置内容，因此，开发者可以根据不同的环境返回不同的对象</p>
<p>在调用webpack函数时，webpack会向函数传入一个参数env，该参数的值来自于webpack命令中给env指定的值，例如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npx webpack --env abc # env: "abc"</span><br><span class="line"></span><br><span class="line">npx webpack --env.abc # env: &#123;abc:true&#125;</span><br><span class="line">npx webpack --env.abc=1  # env： &#123;abc:1&#125;</span><br><span class="line">npx webpack --env.abc=1 --env.bcd=2 # env: &#123;abc:1, bcd:2&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，我们就可以在命令中指定环境，在代码中进行判断，根据环境返回不同的配置结果。</p>
<h4 id="mode配置"><a href="#mode配置" class="headerlink" title="mode配置"></a>mode配置</h4><p>编译模式，字符串，取值为development或production，指定编译结果代码运行的环境，会影响webpack对编译结果代码格式的处理<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">"development"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="devtool配置"><a href="#devtool配置" class="headerlink" title="devtool配置"></a>devtool配置</h4><p>前端发展到现阶段，很多时候都不会直接运行源代码，可能需要对源代码进行合并、压缩、转换等操作，真正运行的是转换后的代码<br><img src="/2020/03/06/JavaScript-webpack/2020-01-08-16-38-26.png" alt><br>这就给调试带来了困难，因为当运行发生错误的时候，我们更加希望能看到源代码中的错误，而不是转换后代码的错误</p>
<blockquote>
<p>jquery压缩后的代码：<a href="https://code.jquery.com/jquery-3.4.1.min.js" target="_blank" rel="noopener">https://code.jquery.com/jquery-3.4.1.min.js</a></p>
</blockquote>
<p>为了解决这一问题，chrome浏览器率先支持了source map，其他浏览器纷纷效仿，目前，几乎所有新版浏览器都支持了source map</p>
<p>source map实际上是一个配置，配置中不仅记录了所有源码内容，还记录了和转换后的代码的对应关系</p>
<p>下面是浏览器处理source map的原理</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-08-16-58-06.png" alt></p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-08-17-01-13.png" alt></p>
<ol>
<li>source map 应在开发环境中使用，作为一种调试手段</li>
<li>source map 不应该在生产环境中使用，source map的文件一般较大，不仅会导致额外的网络传输，还容易暴露原始代码。即便要在生产环境中使用source map，用于调试真实的代码运行问题，也要做出一些处理规避网络传输和代码暴露的问题。</li>
</ol>
<p><strong>webpack中的source map</strong><br>使用 webpack 编译后的代码难以调试，可以通过 devtool 配置来<strong>优化调试体验</strong><br>具体的配置见文档：<a href="https://www.webpackjs.com/configuration/devtool/" target="_blank" rel="noopener">https://www.webpackjs.com/configuration/devtool/</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">"development"</span>,</span><br><span class="line">    devtool: <span class="string">"source-map"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="入口和出口"><a href="#入口和出口" class="headerlink" title="入口和出口"></a>入口和出口</h4><p><img src="/2020/03/06/JavaScript-webpack/2020-01-09-15-51-07.png" alt></p>
<blockquote>
<p>node内置模块 - path: <a href="https://nodejs.org/dist/latest-v12.x/docs/api/path.html" target="_blank" rel="noopener">https://nodejs.org/dist/latest-v12.x/docs/api/path.html</a></p>
</blockquote>
<p><strong>路径问题补充</strong></p>
<ol>
<li>模块化代码中，比如require(“./“)，表示当前js文件所在的目录</li>
<li>在路径处理中，”./“表示node运行目录</li>
<li>__dirname: 所有情况下，都表示当前运行的js文件所在的目录，它是一个绝对路径</li>
<li>node内中模块<code>path</code>该对象提供了大量路径处理的函数,其中resolve主要是用来组合路径的.</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c:\WorkSpace\VsCode\webpack\4.配置文件\出口和入口\路径问题\index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> result = path.resolve(<span class="string">"./"</span>, <span class="string">"child"</span>, <span class="string">"123"</span>);</span><br><span class="line"><span class="keyword">var</span> result1 = path.resolve(__dirname, <span class="string">"src"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(__dirname);<span class="comment">//c:\WorkSpace\VsCode\webpack\4.配置文件\出口和入口\路径问题</span></span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//取决于在哪里运行js,然后拼接child和123</span></span><br><span class="line"><span class="built_in">console</span>.log(result1);<span class="comment">//c:\WorkSpace\VsCode\webpack\4.配置文件\出口和入口\路径问题\src</span></span><br></pre></td></tr></table></figure>
<p><strong>出口</strong><br>这里的出口是针对资源列表的文件名或路径的配置<br>出口通过output进行配置</p>
<p><strong>入口</strong><br><strong>入口真正配置的是chunk</strong><br>入口通过entry进行配置</p>
<p>规则：</p>
<ul>
<li>name：chunkname</li>
<li>hash: 总的资源hash，通常用于解决缓存问题</li>
<li>chunkhash: 使用chunkhash</li>
<li>id: 使用chunkid，不推荐</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">"development"</span>,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: <span class="string">"./src/index.js"</span>, <span class="comment">//属性名：chunk的名称， 属性值：入口模块（启动模块）&lt;==&gt; entry:"./src/index.js"</span></span><br><span class="line">        a: [<span class="string">"./src/a.js"</span>, <span class="string">"./src/index.js"</span>] <span class="comment">//启动模块有两个</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//配置为固定名称</span></span><br><span class="line">    <span class="comment">// output: &#123;</span></span><br><span class="line">    <span class="comment">//     path: path.resolve(__dirname, "target"), //必须配置一个绝对路径，表示资源放置的文件夹，默认是dist</span></span><br><span class="line">    <span class="comment">//     filename: "bundle.js", //配置的合并的js文件的规则</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//name参数</span></span><br><span class="line">    <span class="comment">// output: &#123;</span></span><br><span class="line">    <span class="comment">//     path: path.resolve(__dirname, "target"), //必须配置一个绝对路径，表示资源放置的文件夹，默认是dist</span></span><br><span class="line">    <span class="comment">//     filename: "[name]bundle.js", //配置的合并的js文件的规则</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//hash参数</span></span><br><span class="line">    <span class="comment">// output: &#123;</span></span><br><span class="line">    <span class="comment">//     path: path.resolve(__dirname, "target"), //必须配置一个绝对路径，表示资源放置的文件夹，默认是dist</span></span><br><span class="line">    <span class="comment">//     filename: "[hash:5]bundle.js", //配置的合并的js文件的规则</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//chunkhash参数</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">"target"</span>), <span class="comment">//必须配置一个绝对路径，表示资源放置的文件夹，默认是dist</span></span><br><span class="line">        filename: <span class="string">"[chunkhash:5][name].js"</span>, <span class="comment">//配置的合并的js文件的规则</span></span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: <span class="string">"source-map"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最佳实践:</p>
<p>具体情况具体分析</p>
<p>下面是一些经典场景</p>
<ol>
<li>一个页面一个JS<br><img src="/2020/03/06/JavaScript-webpack/2020-01-10-12-00-28.png" alt></li>
</ol>
<p>源码结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|—— src</span><br><span class="line">    |—— pageA   页面A的代码目录</span><br><span class="line">        |—— index.js 页面A的启动模块</span><br><span class="line">        |—— ...</span><br><span class="line">    |—— pageB   页面B的代码目录</span><br><span class="line">        |—— index.js 页面B的启动模块</span><br><span class="line">        |—— ...</span><br><span class="line">    |—— pageC   页面C的代码目录</span><br><span class="line">        |—— main1.js 页面C的启动模块1 例如：主功能</span><br><span class="line">        |—— main2.js 页面C的启动模块2 例如：实现访问统计的额外功能</span><br><span class="line">        |—— ...</span><br><span class="line">    |—— common  公共代码目录</span><br><span class="line">        |—— ...</span><br></pre></td></tr></table></figure>
<p>webpack配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry:&#123;</span><br><span class="line">        pageA: <span class="string">"./src/pageA/index.js"</span>,</span><br><span class="line">        pageB: <span class="string">"./src/pageB/index.js"</span>,</span><br><span class="line">        pageC: [<span class="string">"./src/pageC/main1.js"</span>, <span class="string">"./src/pageC/main2.js"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:<span class="string">"[name].[chunkhash:5].js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式适用于页面之间的功能差异巨大、公共代码较少的情况，这种情况下打包出来的最终代码不会有太多重复</p>
<ol start="2">
<li>一个页面多个JS<br><img src="/2020/03/06/JavaScript-webpack/2020-01-10-12-38-03.png" alt></li>
</ol>
<p>源码结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">|—— src</span><br><span class="line">    |—— pageA   页面A的代码目录</span><br><span class="line">        |—— index.js 页面A的启动模块</span><br><span class="line">        |—— ...</span><br><span class="line">    |—— pageB   页面B的代码目录</span><br><span class="line">        |—— index.js 页面B的启动模块</span><br><span class="line">        |—— ...</span><br><span class="line">    |—— statistics   用于统计访问人数功能目录</span><br><span class="line">        |—— index.js 启动模块</span><br><span class="line">        |—— ...</span><br><span class="line">    |—— common  公共代码目录</span><br><span class="line">        |—— ...</span><br></pre></td></tr></table></figure>
<p>webpack配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry:&#123;</span><br><span class="line">        pageA: <span class="string">"./src/pageA/index.js"</span>,</span><br><span class="line">        pageB: <span class="string">"./src/pageB/index.js"</span>,</span><br><span class="line">        statistics: <span class="string">"./src/statistics/index.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:<span class="string">"[name].[chunkhash:5].js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式适用于页面之间有一些<strong>独立</strong>、相同的功能，专门使用一个chunk抽离这部分JS有利于浏览器更好的缓存这部分内容。</p>
<blockquote>
<p>思考：为什么不使用多启动模块的方式？</p>
</blockquote>
<ol start="3">
<li>单页应用<br>所谓单页应用，是指整个网站（或网站的某一个功能块）只有一个页面，页面中的内容全部靠JS创建和控制。 vue和react都是实现单页应用的利器。</li>
</ol>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-10-12-44-13.png" alt></p>
<p>源码结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|—— src</span><br><span class="line">    |—— subFunc   子功能目录</span><br><span class="line">        |—— ...</span><br><span class="line">    |—— subFunc   子功能目录</span><br><span class="line">        |—— ...</span><br><span class="line">    |—— common  公共代码目录</span><br><span class="line">        |—— ...</span><br><span class="line">    |—— index.js</span><br></pre></td></tr></table></figure>
<p>webpack配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">"./src/index.js"</span>,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:<span class="string">"index.[hash:5].js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><blockquote>
<p>webpack做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。<br>更多的功能需要借助webpack loaders和webpack plugins完成。</p>
</blockquote>
<p>webpack loader： loader本质上是一个函数，它的作用是将某个源码字符串转换成另一个源码字符串返回。</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-13-10-39-24.png" alt></p>
<p>loader函数的将在模块解析的过程中被调用，以得到最终的源码。</p>
<p><strong>全流程：</strong></p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-13-09-28-52.png" alt></p>
<p><strong>chunk中解析模块的流程：</strong></p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-13-09-29-08.png" alt></p>
<p><strong>chunk中解析模块的更详细流程：</strong></p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-13-09-35-44.png" alt></p>
<p><strong>处理loaders流程：</strong></p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-13-10-29-54.png" alt></p>
<p><strong>loader配置：</strong></p>
<p><strong>完整配置</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123; <span class="comment">//针对模块的配置，目前版本只有两个配置，rules、noParse(是否不要解析某个模块)</span></span><br><span class="line">        rules: [ <span class="comment">//模块匹配规则，可以存在多个规则</span></span><br><span class="line">            &#123; <span class="comment">//每个规则是一个对象</span></span><br><span class="line">                test: <span class="regexp">/\.js$/</span>, <span class="comment">//匹配的模块正则</span></span><br><span class="line">                use: [ <span class="comment">//匹配到后应用的规则模块</span></span><br><span class="line">                    &#123;  <span class="comment">//其中一个规则</span></span><br><span class="line">                        loader: <span class="string">"模块路径"</span>, <span class="comment">//loader模块的路径，该字符串会被放置到require中</span></span><br><span class="line">                        options: &#123; <span class="comment">//向对应loader传递的额外参数</span></span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>简化配置</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123; <span class="comment">//针对模块的配置，目前版本只有两个配置，rules、noParse</span></span><br><span class="line">        rules: [ <span class="comment">//模块匹配规则，可以存在多个规则</span></span><br><span class="line">            &#123; <span class="comment">//每个规则是一个对象</span></span><br><span class="line">                test: <span class="regexp">/\.js$/</span>, <span class="comment">//匹配的模块正则</span></span><br><span class="line">                use: [<span class="string">"模块路径1"</span>, <span class="string">"模块路径2"</span>]<span class="comment">//loader模块的路径，该字符串会被放置到require中,执行顺序会从后往前</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自己写的loader只能用Commonjs模块化规范</strong></p>
<h4 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h4><p>loader的功能定位是转换代码，而一些其他的操作难以使用loader完成，比如：</p>
<ul>
<li>当webpack生成文件时，顺便多生成一个说明描述文件</li>
<li>当webpack编译启动时，控制台输出一句话表示webpack启动了</li>
<li>当xxxx时，xxxx</li>
</ul>
<p>这种类似的功能需要把功能嵌入到webpack的编译流程中，而这种事情的实现是依托于plugin的</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-15-12-45-16.png" alt></p>
<p>plugin的<strong>本质</strong>是一个带有apply方法的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> plugin = &#123;</span><br><span class="line">    apply: <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常，习惯上，我们会将该对象写成构造函数的模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span></span>&#123;</span><br><span class="line">    apply(compiler)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plugin = <span class="keyword">new</span> MyPlugin();</span><br></pre></td></tr></table></figure>
<p>要将插件应用到webpack，需要把插件对象配置到webpack的plugins数组中，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> MyPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>apply函数会在初始化阶段，创建好Compiler对象后运行。</p>
<p>compiler对象是在初始化阶段构建的，整个webpack打包期间只有一个compiler对象，后续完成打包工作的是compiler对象内部创建的compilation</p>
<p>apply方法会在<strong>创建好compiler对象后调用</strong>，并向方法传入一个compiler对象</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-15-12-49-26.png" alt></p>
<p>compiler对象提供了大量的钩子函数（hooks，可以理解为事件），plugin的开发者可以注册这些钩子函数，参与webpack编译和生成。</p>
<p>你可以在apply方法中使用下面的代码注册钩子函数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span></span>&#123;</span><br><span class="line">    apply(compiler)&#123;</span><br><span class="line">        <span class="comment">//在这里注册事件,类似与window.onload $(function()&#123;&#125;)</span></span><br><span class="line">        compiler.hooks.事件名称.事件类型(name, <span class="function"><span class="keyword">function</span>(<span class="params">compilation</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//事件处理函数</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>事件名称</strong></p>
<p>即要监听的事件名，即钩子名，所有的钩子：<a href="https://www.webpackjs.com/api/compiler-hooks" target="_blank" rel="noopener">https://www.webpackjs.com/api/compiler-hooks</a></p>
<p><strong>事件类型</strong></p>
<p>这一部分使用的是 Tapable API，这个小型的库是一个专门用于钩子函数监听的库。</p>
<p>它提供了一些事件类型：</p>
<ul>
<li>tap：注册一个同步的钩子函数，函数运行完毕则表示事件处理结束</li>
<li>tapAsync：注册一个基于回调的异步的钩子函数，函数通过调用一个回调表示事件处理结束</li>
<li>tapPromise：注册一个基于Promise的异步的钩子函数，函数通过返回的Promise进入已决状态表示事件处理结束</li>
</ul>
<p><strong>处理函数</strong></p>
<p>处理函数有一个事件参数<code>compilation</code></p>
<h4 id="其他细节配置"><a href="#其他细节配置" class="headerlink" title="其他细节配置"></a>其他细节配置</h4><ul>
<li>context<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context: path.resolve(__dirname, <span class="string">"app"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>该配置会影响入口和loaders的解析，入口和loaders的相对路径会以context的配置作为基准路径，这样，你的配置会独立于CWD（current working directory 当前执行路径）</p>
<ul>
<li><p>output</p>
<ul>
<li>library<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">library: <span class="string">"abc"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样一来，打包后的结果中，会将自执行函数的执行结果暴露给abc </p>
<ul>
<li>libraryTarget<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libraryTarget: <span class="string">"var"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>该配置可以更加精细的控制如何暴露入口包的导出结果<br>其他可用的值有：</p>
<ol>
<li>var：默认值，暴露给一个普通变量</li>
<li>window：暴露给window对象的一个属性</li>
<li>this：暴露给this的一个属性</li>
<li>this：暴露给this的一个属性</li>
<li>global：暴露给global的一个属性</li>
<li>commonjs：暴露给exports的一个属性</li>
<li>其他：<a href="https://www.webpackjs.com/configuration/output/#output-librarytarget" target="_blank" rel="noopener">https://www.webpackjs.com/configuration/output/#output-librarytarget</a></li>
</ol>
</li>
<li>target<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target:<span class="string">"web"</span> <span class="comment">//默认值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>设置打包结果最终要运行的环境，常用值有</p>
<ol>
<li>web: 打包后的代码运行在web环境中</li>
<li>node：打包后的代码运行在node环境中</li>
<li>其他：<a href="https://www.webpackjs.com/configuration/target/" target="_blank" rel="noopener">https://www.webpackjs.com/configuration/target/</a></li>
</ol>
<ul>
<li>module.noParse<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">noParse: <span class="regexp">/jquery/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>不解析正则表达式匹配的模块，通常用它来忽略那些大型的单模块库，以提高<strong>构建性能</strong></p>
<ul>
<li><p>resolve<br>resolve的相关配置主要用于控制模块解析过程</p>
<ul>
<li>modules<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modules: [<span class="string">"node_modules"</span>]  <span class="comment">//默认值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当解析模块时，如果遇到导入语句，<code>require(&quot;test&quot;)</code>，webpack会从下面的位置寻找依赖的模块</p>
<ol>
<li>当前目录下的<code>node_modules</code>目录</li>
<li>上级目录下的<code>node_modules</code>目录</li>
<li>…</li>
</ol>
<ul>
<li>extensions<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extensions: [<span class="string">".js"</span>, <span class="string">".json"</span>]  <span class="comment">//默认值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当解析模块时，遇到无具体后缀的导入语句，例如<code>require(&quot;test&quot;)</code>，会依次测试它的后缀名</p>
<ul>
<li>alias<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  <span class="string">"@"</span>: path.resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line">  <span class="string">"_"</span>: __dirname</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>有了alias（别名）后，导入语句中可以加入配置的键名，例如<code>require(&quot;@/abc.js&quot;)</code>，webpack会将其看作是<code>require(src的绝对路径+&quot;/abc.js&quot;)</code>。<br>在大型系统中，源码结构往往比较深和复杂，别名配置可以让我们更加方便的导入依赖</p>
</li>
<li>externals</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">    jquery: <span class="string">"$"</span>,</span><br><span class="line">    lodash: <span class="string">"_"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从最终的bundle中排除掉配置的配置的源码，例如，入口模块是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"jquery"</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"lodash"</span>)</span><br></pre></td></tr></table></figure>
<p>生成的bundle是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)(&#123;</span><br><span class="line">    <span class="string">"./src/index.js"</span>: <span class="function"><span class="keyword">function</span>(<span class="params">module, exports, __webpack_require__</span>)</span>&#123;</span><br><span class="line">        __webpack_require__(<span class="string">"jquery"</span>)</span><br><span class="line">        __webpack_require__(<span class="string">"lodash"</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"jquery"</span>: <span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//jquery的大量源码</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"lodash"</span>: <span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//lodash的大量源码</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>但有了上面的配置后，则变成了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)(&#123;</span><br><span class="line">    <span class="string">"./src/index.js"</span>: <span class="function"><span class="keyword">function</span>(<span class="params">module, exports, __webpack_require__</span>)</span>&#123;</span><br><span class="line">        __webpack_require__(<span class="string">"jquery"</span>)</span><br><span class="line">        __webpack_require__(<span class="string">"lodash"</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"jquery"</span>: <span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">module</span>.exports = $;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"lodash"</span>: <span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">module</span>.exports = _;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这比较适用于一些第三方库来自于外部CDN的情况，这样一来，即可以在页面中使用CDN，又让bundle的体积变得更小，还不影响源码的编写</p>
<ul>
<li>stats</li>
</ul>
<p>stats控制的是构建过程中控制台的输出内容</p>
<h3 id="常用扩展"><a href="#常用扩展" class="headerlink" title="常用扩展"></a>常用扩展</h3><ol>
<li>清除输出目录</li>
</ol>
<p><code>clean-webpack-plugin</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">"clean-webpack-plugin"</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name].[chunkhash:5].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>自动生成页面<br><code>html-webpack-plugin</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line">    devtool: <span class="string">'source-map'</span>,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        home: <span class="string">'./src/index.js'</span>,</span><br><span class="line">        a: <span class="string">'./src/a.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'scripts/[name].[chunkhash:5].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">'./public/index.html'</span>,</span><br><span class="line">            filename: <span class="string">'home.html'</span>,</span><br><span class="line">            chunks: [<span class="string">"home"</span>]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">'./public/index.html'</span>,</span><br><span class="line">            filename: <span class="string">'a.html'</span>,</span><br><span class="line">            chunks: [<span class="string">"a"</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>复制静态资源<br><code>copy-webpack-plugin</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    CleanWebpackPlugin</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CopyPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line">    devtool: <span class="string">'source-map'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'scripts/[name].[chunkhash:5].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">"./public/index.html"</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="comment">// new CopyPlugin([&#123;</span></span><br><span class="line">        <span class="comment">//     from: "./public",</span></span><br><span class="line">        <span class="comment">//     to: "./"</span></span><br><span class="line">        <span class="comment">// &#125;,]) //必须加,不然会报错</span></span><br><span class="line">        <span class="keyword">new</span> CopyPlugin([&#123;</span><br><span class="line">            <span class="keyword">from</span>: <span class="string">"./public"</span>,</span><br><span class="line">            to: <span class="string">"./"</span></span><br><span class="line">        &#125;])</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>开发服务器</li>
</ol>
<p>在<strong>开发阶段</strong>，目前遇到的问题是打包、运行、调试过程过于繁琐，回顾一下我们的操作流程：</p>
<ol>
<li>编写代码</li>
<li>控制台运行命令完成打包</li>
<li>打开页面查看效果</li>
<li>继续编写代码，回到步骤2</li>
</ol>
<p>并且，我们往往希望把最终生成的代码和页面部署到服务器上，来模拟真实环境</p>
<p>为了解决这些问题，webpack官方制作了一个单独的库：<strong>webpack-dev-server</strong></p>
<p>它<strong>既不是plugin也不是loader</strong></p>
<p>先来看看它怎么用</p>
<ol>
<li>安装</li>
<li>执行<code>webpack-dev-server</code>命令</li>
</ol>
<p><code>webpack-dev-server</code>命令几乎支持所有的webpack命令参数，如<code>--config</code>、<code>-env</code>等等，你可以把它当作webpack命令使用</p>
<p>这个命令是专门为开发阶段服务的，真正部署的时候还是得使用webpack命令</p>
<p>当我们执行<code>webpack-dev-server</code>命令后，它做了以下操作：</p>
<ol>
<li>内部执行webpack命令，传递命令参数</li>
<li>开启watch</li>
<li>注册hooks：类似于plugin，webpack-dev-server会向webpack中注册一些钩子函数，主要功能如下：<ol>
<li>将资源列表（aseets）保存起来</li>
<li>禁止webpack输出文件</li>
</ol>
</li>
<li>用express开启一个服务器，监听某个端口，当请求到达后，根据请求的路径，给予相应的资源内容<br><strong>配置</strong></li>
</ol>
<p>针对webpack-dev-server的配置，参考：<a href="https://www.webpackjs.com/configuration/dev-server/" target="_blank" rel="noopener">https://www.webpackjs.com/configuration/dev-server/</a></p>
<p>常见配置有：</p>
<ul>
<li>port：配置监听端口</li>
<li>proxy：配置代理，常用于跨域访问</li>
<li>stats：配置控制台输出内容</li>
</ul>
<ol start="5">
<li>普通文件处理</li>
</ol>
<p>file-loader: 生成依赖的文件到输出目录，然后将模块文件设置为：导出一个路径\</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// source：文件内容（图片内容 buffer）</span></span><br><span class="line">	<span class="comment">// 1. 生成一个具有相同文件内容的文件到输出目录</span></span><br><span class="line">	<span class="comment">// 2. 返回一段代码   export default "文件名"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>url-loader：将依赖的文件转换为：导出一个base64格式的字符串,设置了limit属性,符合条件转base64,不符合条件则交给file-loader,包括参数也会提交过去.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// source：文件内容（图片内容 buffer）</span></span><br><span class="line">	<span class="comment">// 1. 根据buffer生成一个base64编码</span></span><br><span class="line">	<span class="comment">// 2. 返回一段代码   export default "base64编码"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>解决路径问题</li>
</ol>
<p>在使用file-loader或url-loader时，可能会遇到一个非常有趣的问题</p>
<p>比如，通过webpack打包的目录结构如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">dist</span></span><br><span class="line">    <span class="string">|——</span> <span class="string">img</span></span><br><span class="line">        <span class="string">|——</span> <span class="string">a.png</span>  <span class="comment">#file-loader生成的文件</span></span><br><span class="line">    <span class="string">|——</span> <span class="string">scripts</span></span><br><span class="line">        <span class="string">|——</span> <span class="string">main.js</span>  <span class="comment">#export default "img/a.png"</span></span><br><span class="line">    <span class="string">|——</span> <span class="string">html</span></span><br><span class="line">        <span class="string">|——</span> <span class="string">index.html</span> <span class="comment">#&lt;script src="../scripts/main.js" &gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种问题发生的根本原因：模块中的路径来自于某个loader或plugin，当产生路径时，loader或plugin只有相对于dist目录的路径，并不知道该路径将在哪个资源中使用，从而无法确定最终正确的路径</p>
<p>面对这种情况，需要依靠webpack的配置publicPath解决</p>
<h3 id="webpack内置插件"><a href="#webpack内置插件" class="headerlink" title="webpack内置插件"></a>webpack内置插件</h3><p>所有的webpack内置插件都作为webpack的静态属性存在的，使用下面的方式即可创建一个插件对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> webpack.插件名(options)</span><br></pre></td></tr></table></figure>
<ol>
<li>DefinePlugin</li>
</ol>
<p>全局常量定义插件，使用该插件通常定义一些常量值，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">    PI: <span class="string">`Math.PI`</span>, <span class="comment">// PI = Math.PI</span></span><br><span class="line">    VERSION: <span class="string">`"1.0.0"`</span>, <span class="comment">// VERSION = "1.0.0"</span></span><br><span class="line">    DOMAIN: <span class="built_in">JSON</span>.stringify(<span class="string">"duyi.com"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样一来，在源码中，我们可以直接使用插件中提供的常量，当webpack编译完成后，会自动替换为常量的值</p>
<ol start="2">
<li>BannerPlugin</li>
</ol>
<p>它可以为每个chunk生成的文件头部添加一行注释，一般用于添加作者、公司、版权等信息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.BannerPlugin(&#123;</span><br><span class="line">  banner: <span class="string">`</span></span><br><span class="line"><span class="string">  hash:[hash]</span></span><br><span class="line"><span class="string">  chunkhash:[chunkhash]</span></span><br><span class="line"><span class="string">  name:[name]</span></span><br><span class="line"><span class="string">  author:yuanjin</span></span><br><span class="line"><span class="string">  corporation:duyi</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>ProvidePlugin</li>
</ol>
<p>自动加载模块，而不必到处 import 或 require </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">  $: <span class="string">'jquery'</span>,</span><br><span class="line">  _: <span class="string">'lodash'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后在我们任意源码中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#item'</span>); <span class="comment">// &lt;= 起作用</span></span><br><span class="line">_.drop([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>); <span class="comment">// &lt;= 起作用</span></span><br></pre></td></tr></table></figure>
<h2 id="css工程化"><a href="#css工程化" class="headerlink" title="css工程化"></a>css工程化</h2><h3 id="css工程化概述"><a href="#css工程化概述" class="headerlink" title="css工程化概述"></a>css工程化概述</h3><h4 id="css的问题"><a href="#css的问题" class="headerlink" title="css的问题"></a>css的问题</h4><ol>
<li>类名冲突问题<br>当你写一个css类的时候，你是写全局的类呢，还是写多个层级选择后的类呢？</li>
</ol>
<p>你会发现，怎么都不好</p>
<ul>
<li>过深的层级不利于编写、阅读、压缩、复用</li>
<li>过浅的层级容易导致类名冲突</li>
</ul>
<p>一旦样式多起来，这个问题就会变得越发严重，其实归根结底，就是类名冲突不好解决的问题</p>
<ol start="2">
<li>重复样式<br>这种问题就更普遍了，一些重复的样式值总是不断的出现在css代码中，维护起来极其困难<br>比如，一个网站的颜色一般就那么几种：</li>
</ol>
<ul>
<li>primary</li>
<li>info</li>
<li>warn</li>
<li>error</li>
<li>success</li>
</ul>
<p>如果有更多的颜色，都是从这些色调中自然变化得来，可以想象，这些颜色会到处充斥到诸如背景、文字、边框中，一旦要做颜色调整，是一个非常大的工程</p>
<ol start="3">
<li>css文件细分问题</li>
</ol>
<p>在大型项目中，css也需要更细的拆分，这样有利于css代码的维护。</p>
<p>比如，有一个做轮播图的模块，它不仅需要依赖js功能，还需要依赖css样式，既然依赖的js功能仅关心轮播图，那css样式也应该仅关心轮播图，由此类推，不同的功能依赖不同的css样式、公共样式可以单独抽离，这样就形成了不同于过去的css文件结构：文件更多、拆分的更细</p>
<p>而同时，在真实的运行环境下，我们却希望文件越少越好，这种情况和JS遇到的情况是一致的</p>
<p>因此，对于css，也需要工程化管理</p>
<p>从另一个角度来说，css的工程化会遇到更多的挑战，因为css不像JS，它的语法本身经过这么多年并没有发生多少的变化（css3也仅仅是多了一些属性而已），对于css语法本身的改变也是一个工程化的课题</p>
<h4 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h4><p>这么多年来，官方一直没有提出方案来解决上述问题</p>
<p>一些第三方机构针对不同的问题，提出了自己的解决方案</p>
<ol>
<li>解决类名冲突</li>
</ol>
<p>一些第三方机构提出了一些方案来解决该问题，常见的解决方案如下：</p>
<p><strong>命名约定</strong></p>
<p>即提供一种命名的标准，来解决冲突，常见的标准有：</p>
<ul>
<li>BEM</li>
<li>OOCSS</li>
<li>AMCSS</li>
<li>SMACSS</li>
<li>其他</li>
</ul>
<p><strong>css in js</strong></p>
<p>这种方案非常大胆，它觉得，css语言本身几乎无可救药了，干脆直接用js对象来表示样式，然后把样式直接应用到元素的style中</p>
<p>这样一来，css变成了一个一个的对象，就可以完全利用到js语言的优势，你可以：</p>
<ul>
<li>通过一个函数返回一个样式对象</li>
<li>把公共的样式提取到公共模块中返回</li>
<li>应用js的各种特性操作对象，比如：混合、提取、拆分</li>
<li>更多的花样</li>
</ul>
<blockquote>
<p>这种方案在手机端的React Native中大行其道</p>
</blockquote>
<p><strong>css module</strong></p>
<p>非常有趣和好用的css模块化方案，编写简单，绝对不重名</p>
<ol start="2">
<li>解决重复样式的问题</li>
</ol>
<p><strong>css in js</strong></p>
<p>这种方案虽然可以利用js语言解决重复样式值的问题，但由于太过激进，很多习惯写css的开发者编写起来并不是很适应</p>
<p><strong>预编译器</strong></p>
<p>有些第三方搞出一套css语言的进化版来解决这个问题，它支持变量、函数等高级语法，然后经过编译器将其编译成为正常的css</p>
<p>这种方案特别像构建工具，不过它仅针对css</p>
<p>常见的预编译器支持的语言有：</p>
<ul>
<li>less</li>
<li>sass</li>
</ul>
<ol start="3">
<li>解决css文件细分问题</li>
</ol>
<p>这一部分，就要依靠构建工具，例如webpack来解决了</p>
<p>利用一些loader或plugin来打包、合并、压缩css文件</p>
<h3 id="利用webapck拆分css"><a href="#利用webapck拆分css" class="headerlink" title="利用webapck拆分css"></a>利用webapck拆分css</h3><p>要拆分css，就必须把css当成像js那样的模块；要把css当成模块，就必须有一个构建工具（webpack），它具备合并代码的能力</p>
<p>而webpack本身只能读取css文件的内容、将其当作JS代码进行分析，因此，会导致错误</p>
<p>于是，就必须有一个loader，能够将css代码转换为js代码</p>
<ul>
<li>css-loader</li>
</ul>
<p>css-loader的作用，就是将css代码转换为js代码</p>
<p>它的处理原理极其简单：将css代码作为字符串导出</p>
<p>例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.red</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="string">"#f40"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过css-loader转换后变成js代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="string">`.red&#123;</span></span><br><span class="line"><span class="string">    color:"#f40";</span></span><br><span class="line"><span class="string">&#125;`</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的js代码是经过我简化后的，不代表真实的css-loader的转换后代码，css-loader转换后的代码会有些复杂，同时会导出更多的信息，但核心思想不变</p>
</blockquote>
<p>再例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.red</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="string">"#f40"</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"./bg.png"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过css-loader转换后变成js代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> import1 = <span class="built_in">require</span>(<span class="string">"./bg.png"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">`.red&#123;</span></span><br><span class="line"><span class="string">    color:"#f40";</span></span><br><span class="line"><span class="string">    background:url("<span class="subst">$&#123;import1&#125;</span>")</span></span><br><span class="line"><span class="string">&#125;`</span>;</span><br></pre></td></tr></table></figure>
<p>这样一来，经过webpack的后续处理，会把依赖<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```js</span><br><span class="line">var import1 = __webpack_require__(&quot;./src/bg.png&quot;);</span><br><span class="line">module.exports = `.red&#123;</span><br><span class="line">    color:&quot;#f40&quot;;</span><br><span class="line">    background:url(&quot;$&#123;import1&#125;&quot;)</span><br><span class="line">&#125;`;</span><br></pre></td></tr></table></figure></p>
<p>再例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">"./reset.css"</span>;</span><br><span class="line"><span class="selector-class">.red</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="string">"#f40"</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"./bg.png"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会转换为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> import1 = <span class="built_in">require</span>(<span class="string">"./reset.css"</span>);</span><br><span class="line"><span class="keyword">var</span> import2 = <span class="built_in">require</span>(<span class="string">"./bg.png"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">`<span class="subst">$&#123;import1&#125;</span></span></span><br><span class="line"><span class="string">.red&#123;</span></span><br><span class="line"><span class="string">    color:"#f40";</span></span><br><span class="line"><span class="string">    background:url("<span class="subst">$&#123;import2&#125;</span>")</span></span><br><span class="line"><span class="string">&#125;`</span>;</span><br></pre></td></tr></table></figure>
<p>总结，css-loader干了什么：</p>
<ol>
<li>将css文件的内容作为字符串导出</li>
<li>将css中的其他依赖作为require导入，以便webpack分析依赖</li>
</ol>
<ul>
<li>style-loader</li>
</ul>
<p>由于css-loader仅提供了将css转换为字符串导出的能力，剩余的事情要交给其他loader或plugin来处理</p>
<p>style-loader可以将css-loader转换后的代码进一步处理，将css-loader导出的字符串加入到页面的style元素中</p>
<p>例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.red</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="string">"#f40"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过css-loader转换后变成js代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="string">`.red&#123;</span></span><br><span class="line"><span class="string">    color:"#f40";</span></span><br><span class="line"><span class="string">&#125;`</span></span><br></pre></td></tr></table></figure>
<p>经过style-loader转换后变成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="string">`.red&#123;</span></span><br><span class="line"><span class="string">    color:"#f40";</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line"><span class="keyword">var</span> style = <span class="built_in">module</span>.exports;</span><br><span class="line"><span class="keyword">var</span> styleElem = <span class="built_in">document</span>.createElement(<span class="string">"style"</span>);</span><br><span class="line">styleElem.innerHTML = style;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(styleElem);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上代码均为简化后的代码，并不代表真实的代码<br>style-loader有能力避免同一个样式的重复导入</p>
</blockquote>
<h3 id="BEM-解决类名冲突"><a href="#BEM-解决类名冲突" class="headerlink" title="BEM(解决类名冲突)"></a>BEM(解决类名冲突)</h3><p>BEM是一套针对css类样式的命名方法。</p>
<blockquote>
<p>其他命名方法还有：OOCSS、AMCSS、SMACSS等等</p>
</blockquote>
<p>BEM全称是：<strong>B</strong>lock <strong>E</strong>lement <strong>M</strong>odifier</p>
<p>一个完整的BEM类名：block__element_modifier，例如：<code>banner__dot_selected</code>，可以表示：轮播图中，处于选中状态的小圆点</p>
<p>三个部分的具体含义为：</p>
<ul>
<li><strong>Block</strong>：页面中的大区域，表示最顶级的划分，例如：轮播图(<code>banner</code>)、布局(<code>layout</code>)、文章(<code>article</code>)等等</li>
<li><strong>element</strong>：区域中的组成部分，例如：轮播图中的横幅图片(<code>banner__img</code>)、轮播图中的容器（<code>banner__container</code>）、布局中的头部(<code>layout__header</code>)、文章中的标题(<code>article_title</code>)</li>
<li><strong>modifier</strong>：可选。通常表示状态，例如：处于展开状态的布局左边栏（<code>layout__left_expand</code>）、处于选中状态的轮播图小圆点(<code>banner__dot_selected</code>)</li>
</ul>
<p>在某些大型工程中，如果使用BEM命名法，还可能会增加一个前缀，来表示类名的用途，常见的前缀有：</p>
<ul>
<li><strong>l</strong>: layout，表示这个样式是用于布局的</li>
<li><strong>c</strong>: component，表示这个样式是一个组件，即一个功能区域</li>
<li><strong>u</strong>: util，表示这个样式是一个通用的、工具性质的样式</li>
<li><strong>j</strong>: javascript，表示这个样式没有实际意义，是专门提供给js获取元素使用的</li>
</ul>
<h3 id="css-in-js-解决类名冲突"><a href="#css-in-js-解决类名冲突" class="headerlink" title="css in js(解决类名冲突)"></a>css in js(解决类名冲突)</h3><p>css in js 的核心思想是：用一个JS对象来描述样式，而不是css样式表</p>
<p>例如下面的对象就是一个用于描述样式的对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> styles = &#123;</span><br><span class="line">    backgroundColor: <span class="string">"#f40"</span>,</span><br><span class="line">    color: <span class="string">"#fff"</span>,</span><br><span class="line">    width: <span class="string">"400px"</span>,</span><br><span class="line">    height: <span class="string">"500px"</span>,</span><br><span class="line">    margin: <span class="string">"0 auto"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这种描述样式的方式<strong>根本就不存在类名</strong>，自然不会有类名冲突</p>
<p>至于如何把样式应用到界面上，不是它所关心的事情，你可以用任何技术、任何框架、任何方式将它应用到界面。</p>
<blockquote>
<p>后续学习的vue、react都支持css in js，可以非常轻松的应用到界面</p>
</blockquote>
<p>css in js的特点：</p>
<ul>
<li><strong>绝无冲突的可能</strong>：由于它根本不存在类名，所以绝不可能出现类名冲突</li>
<li><strong>更加灵活</strong>：可以充分利用JS语言灵活的特点，用各种招式来处理样式</li>
<li><strong>应用面更广</strong>：只要支持js语言，就可以支持css in js，因此，在一些用JS语言开发移动端应用的时候非常好用，因为移动端应用很有可能并不支持css</li>
<li><strong>书写不便</strong>：书写样式，特别是公共样式的时候，处理起来不是很方便</li>
<li><strong>在页面中增加了大量冗余内容</strong>：在页面中处理css in js时，往往是将样式加入到元素的style属性中，会大量增加元素的内联样式，并且可能会有大量重复，不易阅读最终的页面代码</li>
</ul>
<h3 id="css-module-解决类名冲突问题"><a href="#css-module-解决类名冲突问题" class="headerlink" title="css module(解决类名冲突问题)"></a>css module(解决类名冲突问题)</h3><blockquote>
<p>通过命名规范来限制类名太过死板，而css in js虽然足够灵活，但是书写不便。<br>css module 开辟一种全新的思路来解决类名冲突的问题</p>
</blockquote>
<ul>
<li>思路<br>css module 遵循以下思路解决类名冲突问题：</li>
</ul>
<ol>
<li>css的类名冲突往往发生在大型项目中</li>
<li>大型项目往往会使用构建工具（webpack等）搭建工程</li>
<li>构建工具允许将css样式切分为更加精细的模块</li>
<li>同JS的变量一样，每个css模块文件中难以出现冲突的类名，冲突的类名往往发生在不同的css模块文件中</li>
<li>只需要保证构建工具在合并样式代码后不会出现类名冲突即可</li>
</ol>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-31-13-54-37.png" alt></p>
<ul>
<li>实现原理</li>
</ul>
<p>在webpack中，作为处理css的css-loader，它实现了css module的思想，要启用css module，需要将css-loader的配置<code>modules</code>设置为<code>true</code>。</p>
<p>css-loader的实现方式如下：</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-31-14-00-56.png" alt></p>
<p>原理极其简单，开启了css module后，css-loader会将样式中的类名进行转换，转换为一个唯一的hash值。</p>
<p>由于hash值是根据模块路径和类名生成的，因此，不同的css模块，哪怕具有相同的类名，转换后的hash值也不一样。</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-31-14-04-11.png" alt></p>
<ul>
<li>如何应用样式</li>
</ul>
<p>css module带来了一个新的问题：源代码的类名和最终生成的类名是不一样的，而开发者只知道自己写的源代码中的类名，并不知道最终的类名是什么，那如何应用类名到元素上呢？</p>
<p>为了解决这个问题，css-loader会导出原类名和最终类名的对应关系，该关系是通过一个对象描述的</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-01-31-14-08-49.png" alt></p>
<p>这样一来，我们就可以在js代码中获取到css模块导出的结果，从而应用类名了</p>
<p>style-loader为了我们更加方便的应用类名，会去除掉其他信息，仅暴露对应关系</p>
<ul>
<li><p>其他操作</p>
<ul>
<li><p>全局类名<br>某些类名是全局的、静态的，不需要进行转换，仅需要在类名位置使用一个特殊的语法即可：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:global(.main)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了global的类名不会进行转换，相反的，没有使用global的类名，表示默认使用了local</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:global(.main)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了local的类名表示局部类名，是可能会造成冲突的类名，会被css module进行转换</p>
</li>
<li>如何控制最终的类名<br>绝大部分情况下，我们都不需要控制最终的类名，因为控制它没有任何意义<br>如果一定要控制最终的类名，需要配置css-loader的<code>localIdentName</code></li>
</ul>
</li>
<li><p>其他注意事项</p>
<ul>
<li>css module往往配合构建工具使用</li>
<li>css module仅处理顶级类名，尽量不要书写嵌套的类名，也没有这个必要</li>
<li>css module仅处理类名，不处理其他选择器</li>
<li>css module还会处理id选择器，不过任何时候都没有使用id选择器的理由</li>
<li>使用了css module后，只要能做到让类名望文知意即可，不需要遵守其他任何的命名规范</li>
</ul>
</li>
</ul>
<h3 id="预编译器less-解决重复样式问题"><a href="#预编译器less-解决重复样式问题" class="headerlink" title="预编译器less(解决重复样式问题)"></a>预编译器less(解决重复样式问题)</h3><ul>
<li>基本原理</li>
</ul>
<p>编写css时，受限于css语言本身，常常难以处理一些问题：</p>
<ul>
<li>重复的样式值：例如常用颜色、常用尺寸</li>
<li>重复的代码段：例如绝对定位居中、清除浮动</li>
<li>重复的嵌套书写</li>
</ul>
<p>由于官方迟迟不对css语言本身做出改进，一些第三方机构开始想办法来解决这些问题</p>
<p>其中一种方案，便是预编译器</p>
<p>预编译器的原理很简单，即使用一种更加优雅的方式来书写样式代码，通过一个编译器，将其转换为可被浏览器识别的传统css代码</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-02-03-11-48-45.png" alt></p>
<p>目前，最流行的预编译器有<strong>LESS</strong>和<strong>SASS</strong>，由于它们两者特别相似，因此仅学习一种即可（本课程学习LESS）</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-02-03-11-50-05.png" alt></p>
<blockquote>
<p>less官网：<a href="http://lesscss.org/" target="_blank" rel="noopener">http://lesscss.org/</a><br>less中文文档1（非官方）：<a href="http://lesscss.cn/" target="_blank" rel="noopener">http://lesscss.cn/</a><br>less中文文档2（非官方）：<a href="https://less.bootcss.com/" target="_blank" rel="noopener">https://less.bootcss.com/</a><br>sass官网：<a href="https://sass-lang.com/" target="_blank" rel="noopener">https://sass-lang.com/</a><br>sass中文文档1（非官方）：<a href="https://www.sass.hk/" target="_blank" rel="noopener">https://www.sass.hk/</a><br>sass中文文档2（非官方）：<a href="https://sass.bootcss.com/" target="_blank" rel="noopener">https://sass.bootcss.com/</a></p>
</blockquote>
<ul>
<li>LESS的安装和使用</li>
</ul>
<p>从原理可知，要使用LESS，必须要安装LESS编译器</p>
<p>LESS编译器是基于node开发的，可以通过npm下载安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D less</span><br></pre></td></tr></table></figure>
<p>安装好了less之后，它提供了一个CLI工具<code>lessc</code>，通过该工具即可完成编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lessc less代码文件 编译后的文件</span><br></pre></td></tr></table></figure>
<p>试一试:</p>
<p>新建一个<code>index.less</code>文件，编写内容如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// less代码</span></span><br><span class="line"><span class="variable">@red:</span> <span class="number">#f40</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.redcolor</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">@red</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lessc index.less index.css</span><br></pre></td></tr></table></figure>
<p>可以看到编译之后的代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.redcolor</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#f40</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>LESS的基本使用<br>具体的使用见文档：<a href="https://less.bootcss.com/" target="_blank" rel="noopener">https://less.bootcss.com/</a><ul>
<li>变量</li>
<li>混合</li>
<li>嵌套</li>
<li>运算</li>
<li>函数</li>
<li>作用域</li>
<li>注释</li>
<li>导入</li>
</ul>
</li>
</ul>
<h3 id="PostCss"><a href="#PostCss" class="headerlink" title="PostCss"></a>PostCss</h3><ul>
<li>什么是PostCss</li>
</ul>
<p>学习到现在，可以看出，CSS工程化面临着诸多问题，而解决这些问题的方案多种多样。</p>
<p>如果把CSS单独拎出来看，光是样式本身，就有很多事情要处理。</p>
<p>既然有这么多事情要处理，何不把这些事情集中到一起统一处理呢？</p>
<p>PostCss就是基于这样的理念出现的。</p>
<p>PostCss类似于一个编译器，可以将样式源码编译成最终的CSS代码</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-02-04-14-31-33.png" alt></p>
<p>看上去是不是和LESS、SASS一样呢？</p>
<p>但PostCss和LESS、SASS的思路不同，它其实只做一些代码分析之类的事情，将分析的结果交给插件，具体的代码转换操作是插件去完成的。</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-02-04-14-37-51.png" alt></p>
<p>官方的一张图更能说明postcss的处理流程：</p>
<p><img src="/2020/03/06/JavaScript-webpack/postcss-workflow.png" alt></p>
<blockquote>
<p>这一点有点像webpack，webpack本身仅做依赖分析、抽象语法树分析，其他的操作是靠插件和加载器完成的。</p>
</blockquote>
<p>官网地址：<a href="https://postcss.org/" target="_blank" rel="noopener">https://postcss.org/</a><br>github地址：<a href="https://github.com/postcss/postcss" target="_blank" rel="noopener">https://github.com/postcss/postcss</a></p>
<ul>
<li>安装</li>
</ul>
<p>PostCss是基于node编写的，因此可以使用npm安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D postcss</span><br></pre></td></tr></table></figure>
<p>postcss库提供了对应的js api用于转换代码，如果你想使用postcss的一些高级功能，或者想开发postcss插件，就要api使用postcss，api的文档地址是：<a href="http://api.postcss.org/" target="_blank" rel="noopener">http://api.postcss.org/</a></p>
<p>不过绝大部分时候，我们都是使用者，并不希望使用代码的方式来使用PostCss</p>
<p>因此，我们可以再安装一个postcss-cli，通过命令行来完成编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D postcss-cli</span><br></pre></td></tr></table></figure>
<p>postcss-cli提供一个命令，它调用postcss中的api来完成编译</p>
<p>命令的使用方式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postcss 源码文件 -o 输出文件</span><br></pre></td></tr></table></figure>
<ul>
<li>配置文件</li>
</ul>
<p>和webpack类似，postcss有自己的配置文件，该配置文件会影响postcss的某些编译行为。</p>
<p>配置文件的默认名称是：<code>postcss.config.js</code></p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    map: <span class="literal">false</span>, <span class="comment">//关闭source-map</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>插件</li>
</ul>
<p>光使用postcss是没有多少意义的，要让它真正的发挥作用，需要插件<br>postcss的插件市场：<a href="https://www.postcss.parts/" target="_blank" rel="noopener">https://www.postcss.parts/</a><br>下面罗列一些postcss的常用插件</p>
<ol>
<li><p>postcss-preset-env<br> 过去使用postcss的时候，往往会使用大量的插件，它们各自解决一些问题这样导致的结果是安装插件、配置插件都特别的繁琐 于是出现了这么一个插  <code>postcss-preset-env</code>，它称之为<code>postcss预设环境</code>，大意就是它整合了很多的常用插件到一起，并帮你完成了基本的配置，你只需要安装它一个  件，就相当于安装了很多插件了。安装好该插件后，在postcss配置中加入下面的配置</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: &#123;</span><br><span class="line">        <span class="string">"postcss-preset-env"</span>: &#123;&#125; <span class="comment">// &#123;&#125; 中可以填写插件的配置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 该插件的功能很多，下面一一介绍</p>
<ol>
<li><p>自动的厂商前缀<br> 某些新的css样式需要在旧版本浏览器中使用厂商前缀方可实现<br> 例如</p>
 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">::placeholder</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 该功能在不同的旧版本浏览器中需要书写为</p>
 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">::-webkit-input-placeholder</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-moz-placeholder</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">:-ms-input-placeholder</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-ms-input-placeholder</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::placeholder</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 要完成这件事情，需要使用<code>autoprefixer</code>库。</p>
<p> 而<code>postcss-preset-env</code>内部包含了该库，自动有了该功能。</p>
<p> 如果需要调整<strong>兼容的浏览器</strong>范围，可以通过下面的方式进行配置</p>
<p> <strong>方式1：在postcss-preset-env的配置中加入browsers</strong></p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: &#123;</span><br><span class="line">        <span class="string">"postcss-preset-env"</span>: &#123;</span><br><span class="line">            browsers: [</span><br><span class="line">                <span class="string">"last 2 version"</span>,</span><br><span class="line">                <span class="string">"&gt; 1%"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>方式2【推荐】：添加 .browserslistrc 文件</strong></p>
<p> 创建文件<code>.browserslistrc</code>，填写配置内容</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">last 2 version</span><br><span class="line">&gt; 1%</span><br></pre></td></tr></table></figure>
<p> <strong>方式3【推荐】：在package.json的配置中加入browserslist</strong></p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"browserslist": [</span><br><span class="line">    "last 2 version",</span><br><span class="line">    <span class="string">"&gt; 1%"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p> <code>browserslist</code>是一个多行的（数组形式的）标准字符串。</p>
<p> 它的书写规范多而繁琐，详情见：<a href="https://github.com/browserslist/browserslist" target="_blank" rel="noopener">https://github.com/browserslist/browserslist</a></p>
<p> 一般情况下，大部分网站都使用下面的格式进行书写</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">last 2 version</span><br><span class="line">&gt; 1% in CN</span><br><span class="line">not ie &lt;= 8</span><br></pre></td></tr></table></figure>
<ul>
<li><code>last 2 version</code>: 浏览器的兼容最近期的两个版本</li>
<li><code>&gt; 1% in CN</code>: 匹配中国大于1%的人使用的浏览器， <code>in CN</code>可省略</li>
<li><p><code>not ie &lt;= 8</code>: 排除掉版本号小于等于8的IE浏览器</p>
<blockquote>
<p>默认情况下，匹配的结果求的是并集</p>
</blockquote>
<p>你可以通过网站：<a href="https://browserl.ist/" target="_blank" rel="noopener">https://browserl.ist/</a> 对配置结果覆盖的浏览器进行查询，查询时，多行之间使用英文逗号分割</p>
<blockquote>
<p>browserlist的数据来自于<a href="http://caniuse.com/" target="_blank" rel="noopener">CanIUse</a>网站，由于数据并非实时的，所以不会特别准确</p>
</blockquote>
</li>
</ul>
</li>
<li><p>未来的CSS语法<br> CSS的某些前沿语法正在制定过程中，没有形成真正的标准，如果希望使用这部分语法，为了浏览器兼容性，需要进行编译</p>
<p> 过去，完成该语法编译的是<code>cssnext</code>库，不过有了<code>postcss-preset-env</code>后，它自动包含了该功能。</p>
<p> 你可以通过<code>postcss-preset-env</code>的<code>stage</code>配置，告知<code>postcss-preset-env</code>需要对哪个阶段的css语法进行兼容处理，它的默认值为2</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"postcss-preset-env"</span>: &#123;</span><br><span class="line">    stage: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 一共有5个阶段可配置：</p>
<ul>
<li>Stage 0: Aspirational - 只是一个早期草案，极其不稳定</li>
<li>Stage 1: Experimental - 仍然极其不稳定，但是提议已被W3C公认</li>
<li>Stage 2: Allowable - 虽然还是不稳定，但已经可以使用了</li>
<li>Stage 3: Embraced - 比较稳定，可能将来会发生一些小的变化，它即将成为最终的标准</li>
<li><p>Stage 4: Standardized - 所有主流浏览器都应该支持的W3C标准</p>
<p>了解了以上知识后，接下来了解一下未来的css语法，尽管某些语法仍处于非常早期的阶段，但是有该插件存在，编译后仍然可以被浏览器识别</p>
<ol>
<li>变量<br>未来的css语法是天然支持变量的</li>
</ol>
<p>在<code>:root{}</code>中定义常用变量，使用<code>--</code>前缀命名变量</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">    <span class="attribute">--lightColor</span>: <span class="number">#ddd</span>;</span><br><span class="line">    <span class="attribute">--darkColor</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--lightColor);</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">var</span>(--darkColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译后，仍然可以看到原语法，因为某些新语法的存在并不会影响浏览器的渲染，尽管浏览器可能不认识<br>如果不希望在结果中看到新语法，可以配置<code>postcss-preset-env</code>的<code>preserve</code>为<code>false</code></p>
</blockquote>
<ol>
<li>自定义选择器</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">custom</span>-<span class="keyword">selector</span> :--heading h1, h2, h3, h4, h5, h6;</span><br><span class="line">@<span class="keyword">custom</span>-<span class="keyword">selector</span> :--enter :focus,:hover;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:--enter</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f40</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:--heading</span>&#123;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:--heading.active</span>&#123;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>,<span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f40</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>&#123;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-class">.active</span>,<span class="selector-tag">h2</span><span class="selector-class">.active</span>,<span class="selector-tag">h3</span><span class="selector-class">.active</span>,<span class="selector-tag">h4</span><span class="selector-class">.active</span>,<span class="selector-tag">h5</span><span class="selector-class">.active</span>,<span class="selector-tag">h6</span><span class="selector-class">.active</span>&#123;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>嵌套</li>
</ol>
<p>与LESS相同，只不过嵌套的选择器前必须使用符号<code>&amp;</code></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="selector-tag">&amp;</span> <span class="selector-class">.b</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">&amp;</span> &gt; <span class="selector-class">.b</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.a</span> <span class="selector-class">.b</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.a</span>&gt;<span class="selector-class">.b</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li><p>postcss-apply<br> 该插件可以支持在css中书写属性集类似于LESS中的混入，可以利用CSS的新语法定义一个CSS代码片段，然后在需要的时候应用它</p>
 <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line"><span class="attribute">--center</span>: &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: translate(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="variable">@apply</span> --center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 编译后</p>
 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">-webkit-transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上，该功能也属于cssnext，不知为何<code>postcss-preset-env</code>没有支持 </p>
</blockquote>
</li>
<li><p>postcss-color-function<br> 该插件支持在源码中使用一些颜色函数</p>
 <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="comment">/* 使用颜色#aabbcc，不做任何处理，等同于直接书写 #aabbcc */</span></span><br><span class="line">    <span class="attribute">color</span>: color(<span class="number">#aabbcc</span>);</span><br><span class="line">    <span class="comment">/* 将颜色#aabbcc透明度设置为90% */</span></span><br><span class="line">    <span class="attribute">color</span>: color(<span class="number">#aabbcc</span> a(<span class="number">90%</span>));</span><br><span class="line">    <span class="comment">/* 将颜色#aabbcc的红色部分设置为90% */</span></span><br><span class="line">    <span class="attribute">color</span>: color(<span class="number">#aabbcc</span> red(<span class="number">90%</span>));</span><br><span class="line">    <span class="comment">/* 将颜色#aabbcc调亮50%（更加趋近于白色），类似于less中的lighten函数 */</span></span><br><span class="line">    <span class="attribute">color</span>: color(<span class="number">#aabbcc</span> tint(<span class="number">50%</span>));</span><br><span class="line">    <span class="comment">/* 将颜色#aabbcc调暗50%（更加趋近于黑色），类似于less中的darken函数 */</span></span><br><span class="line">    <span class="attribute">color</span>: color(<span class="number">#aabbcc</span> shade(<span class="number">50%</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 编译后</p>
 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="comment">/* 使用颜色#aabbcc，不做任何处理，等同于直接书写 #aabbcc */</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(170, 187, 204);</span><br><span class="line">    <span class="comment">/* 将颜色#aabbcc透明度设置为90% */</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(170, 187, 204, 0.9);</span><br><span class="line">    <span class="comment">/* 将颜色#aabbcc的红色部分设置为90% */</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(230, 187, 204);</span><br><span class="line">    <span class="comment">/* 将颜色#aabbcc调亮50%（更加趋近于白色），类似于less中的lighten函数 */</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(213, 221, 230);</span><br><span class="line">    <span class="comment">/* 将颜色#aabbcc调暗50%（更加趋近于黑色），类似于less中的darken函数 */</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(85, 94, 102);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>[扩展]postcss-import</p>
<p> 该插件可以让你在<code>postcss</code>文件中导入其他样式代码，通过该插件可以将它们合并</p>
<blockquote>
<p>由于后续的课程中，会将postcss加入到webpack中，而webpack本身具有依赖分析的功能，所以该插件的实际意义不大</p>
</blockquote>
</li>
<li><p>stylelint</p>
<blockquote>
<p>官网：<a href="https://stylelint.io/" target="_blank" rel="noopener">https://stylelint.io/</a></p>
</blockquote>
<p> 在实际的开发中，我们可能会错误的或不规范的书写一些css代码，stylelint插件会即时的发现错误</p>
<p> 由于不同的公司可能使用不同的CSS书写规范，stylelint为了保持灵活，它本身并没有提供具体的规则验证</p>
<p> 你需要安装或自行编写规则验证方案</p>
<p> 通常，我们会安装<code>stylelint-config-standard</code>库来提供标准的CSS规则判定</p>
<p> 安装好后，我们需要告诉stylelint使用该库来进行规则验证</p>
<p> 告知的方式有多种，比较常见的是使用文件<code>.stylelintrc</code></p>
 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//.styleintrc</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"extends"</span>: <span class="string">"stylelint-config-standard"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 此时，如果你的代码出现不规范的地方，编译时将会报出错误</p>
 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <img src="/2020/03/06/JavaScript-webpack/assets/2020-02-05-14-37-11.png" alt></p>
<p> 发生了两处错误：</p>
<ol>
<li>缩进应该只有两个空格</li>
<li><p>十六进制的颜色值不正确</p>
<p>如果某些规则并非你所期望的，可以在配置中进行设置</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"extends"</span>: <span class="string">"stylelint-config-standard"</span>,</span><br><span class="line">    <span class="attr">"rules"</span>: &#123;</span><br><span class="line">        <span class="attr">"indentation"</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置为<code>null</code>可以禁用该规则，或者设置为4，表示一个缩进有4个空格。具体的设置需要参见stylelint文档：<a href="https://stylelint.io/" target="_blank" rel="noopener">https://stylelint.io/</a></p>
<p>但是这种错误报告需要在编译时才会发生，如果我希望在编写代码时就自动在编辑器里报错呢？</p>
<p>既然想在编辑器里达到该功能，那么就要在编辑器里做文章</p>
<p>安装vscode的插件<code>stylelint</code>即可，它会读取你工程中的配置文件，按照配置进行实时报错</p>
<blockquote>
<p>实际上，如果你拥有了<code>stylelint</code>插件，可以不需要在postcss中使用该插件了</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h3 id="抽离css文件"><a href="#抽离css文件" class="headerlink" title="抽离css文件"></a>抽离css文件</h3><p>目前，css代码被css-loader转换后，交给的是style-loader进行处理。</p>
<p>style-loader使用的方式是用一段js代码，将样式加入到style元素中。</p>
<p>而实际的开发中，我们往往希望依赖的样式最终形成一个css文件</p>
<p>此时，就需要用到一个库：<code>mini-css-extract-plugin</code></p>
<p>该库提供了1个plugin和1个loader</p>
<ul>
<li>plugin：负责生成css文件</li>
<li>loader：负责记录要生成的css文件的内容，同时导出开启css-module后的样式对象</li>
</ul>
<p>使用方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">"mini-css-extract-plugin"</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [MiniCssExtractPlugin.loader, <span class="string">"css-loader?modules"</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin() <span class="comment">//负责生成css文件</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>配置生成的文件名</strong></p>
<p>同<code>output.filename</code>的含义一样，即根据chunk生成的样式文件名</p>
<p>配置生成的文件名，例如<code>[name].[contenthash:5].css</code></p>
<p>默认情况下，每个chunk对应一个css文件</p>
<h2 id="js兼容性"><a href="#js兼容性" class="headerlink" title="js兼容性"></a>js兼容性</h2><h3 id="babel的安装和使用"><a href="#babel的安装和使用" class="headerlink" title="babel的安装和使用"></a>babel的安装和使用</h3><blockquote>
<p>官网：<a href="https://babeljs.io/" target="_blank" rel="noopener">https://babeljs.io/</a><br>民间中文网：<a href="https://www.babeljs.cn/" target="_blank" rel="noopener">https://www.babeljs.cn/</a></p>
</blockquote>
<h4 id="babel简介"><a href="#babel简介" class="headerlink" title="babel简介"></a>babel简介</h4><p>babel一词来自于希伯来语，直译为巴别塔</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-02-07-10-12-01.png" alt></p>
<p>巴别塔象征的统一的国度、统一的语言</p>
<p>而今天的JS世界缺少一座巴别塔，不同版本的浏览器能识别的ES标准并不相同，就导致了开发者面对不同版本的浏览器要使用不同的语言，和古巴比伦一样，前端开发也面临着这样的困境。</p>
<p>babel的出现，就是用于解决这样的问题，它是一个编译器，可以把不同标准书写的语言，编译为统一的、能被各种浏览器识别的语言</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-02-07-10-25-56.png" alt></p>
<p>由于语言的转换工作灵活多样，babel的做法和postcss、webpack差不多，它本身仅提供一些分析功能，真正的转换需要依托于插件完成</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-02-07-10-27-30.png" alt></p>
<h4 id="babel的安装"><a href="#babel的安装" class="headerlink" title="babel的安装"></a>babel的安装</h4><p>babel可以和构建工具联合使用，也可以独立使用</p>
<p>如果要独立的使用babel，需要安装下面两个库：</p>
<ul>
<li>@babel/core：babel核心库，提供了编译所需的所有api</li>
<li>@babel/cli：提供一个命令行工具，调用核心库的api完成编译</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D @babel/core @babel/cli</span><br></pre></td></tr></table></figure>
<h4 id="babel的使用"><a href="#babel的使用" class="headerlink" title="babel的使用"></a>babel的使用</h4><p>@babel/cli的使用极其简单</p>
<p>它提供了一个命令<code>babel</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 按文件编译</span><br><span class="line">babel 要编译的文件 -o 编辑结果文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 按目录编译</span><br><span class="line">babel 要编译的整个目录 -d 编译结果放置的目录</span><br></pre></td></tr></table></figure>
<h4 id="babel的配置"><a href="#babel的配置" class="headerlink" title="babel的配置"></a>babel的配置</h4><p>可以看到，babel本身没有做任何事情，真正的编译要依托于<strong>babel插件</strong>和<strong>babel预设</strong>来完成</p>
<blockquote>
<p>babel预设和postcss预设含义一样，是多个插件的集合体，用于解决一系列常见的兼容问题</p>
</blockquote>
<p>如何告诉babel要使用哪些插件或预设呢？需要通过一个配置文件<code>.babelrc</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [],</span><br><span class="line">    <span class="attr">"plugins"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="babel预设"><a href="#babel预设" class="headerlink" title="babel预设"></a>babel预设</h3><p>babel有多种预设，最常见的预设是<code>@babel/preset-env</code></p>
<p><code>@babel/preset-env</code>可以让你使用最新的JS语法，而无需针对每种语法转换设置具体的插件</p>
<p><strong>配置</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [</span><br><span class="line">        <span class="string">"@babel/preset-env"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>兼容的浏览器</strong></p>
<p><code>@babel/preset-env</code>需要根据兼容的浏览器范围来确定如何编译，和postcss一样，可以使用文件<code>.browserslistrc</code>来描述浏览器的兼容范围</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">last 3 version</span><br><span class="line">&gt; 1%</span><br><span class="line">not ie &lt;= 8</span><br></pre></td></tr></table></figure>
<p><strong>自身的配置</strong></p>
<p>和<code>postcss-preset-env</code>一样，<code>@babel/preset-env</code>自身也有一些配置</p>
<blockquote>
<p>具体的配置见：<a href="https://www.babeljs.cn/docs/babel-preset-env#options" target="_blank" rel="noopener">https://www.babeljs.cn/docs/babel-preset-env#options</a></p>
</blockquote>
<p>配置方式是：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [</span><br><span class="line">        [<span class="string">"@babel/preset-env"</span>, &#123;</span><br><span class="line">            <span class="attr">"配置项1"</span>: <span class="string">"配置值"</span>,</span><br><span class="line">            <span class="attr">"配置项2"</span>: <span class="string">"配置值"</span>,</span><br><span class="line">            <span class="attr">"配置项3"</span>: <span class="string">"配置值"</span></span><br><span class="line">        &#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中一个比较常见的配置项是<code>usebuiltins</code>，该配置的默认值是false</p>
<p>它有什么用呢？由于该预设仅转换新的语法，并不对新的API进行任何处理</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>转换的结果为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果遇到没有Promise构造函数的旧版本浏览器，该代码就会报错</p>
<p>而配置<code>usebuiltins</code>可以在编译结果中注入这些新的API，它的值默认为<code>false</code>，表示不注入任何新的API，可以将其设置为<code>usage</code>，表示根据API的使用情况，按需导入API</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [</span><br><span class="line">        [<span class="string">"@babel/preset-env"</span>, &#123;</span><br><span class="line">            <span class="attr">"useBuiltIns"</span>: <span class="string">"usage"</span>,</span><br><span class="line">            <span class="attr">"corejs"</span>: <span class="number">3</span>//指定注入新的api的库的版本</span><br><span class="line">        &#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="babel插件"><a href="#babel插件" class="headerlink" title="babel插件"></a>babel插件</h3><blockquote>
<p>上节课补充：@babel/polyfill 已过时，目前被<code>core-js</code>和<code>generator-runtime</code>所取代</p>
</blockquote>
<p>除了预设可以转换代码之外，插件也可以转换代码，它们的顺序是：</p>
<ul>
<li>插件在 Presets 前运行。</li>
<li>插件顺序从前往后排列。</li>
<li>Preset 顺序是颠倒的（从后往前）。</li>
</ul>
<p>通常情况下，<code>@babel/preset-env</code>只转换那些已经形成正式标准的语法，对于某些处于早期阶段、还没有确定的语法不做转换。</p>
<p>如果要转换这些语法，就要单独使用插件</p>
<p>下面随便列举一些插件</p>
<h4 id="babel-plugin-proposal-class-properties"><a href="#babel-plugin-proposal-class-properties" class="headerlink" title="@babel/plugin-proposal-class-properties"></a><code>@babel/plugin-proposal-class-properties</code></h4><p>该插件可以让你在类中书写初始化字段</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="babel-plugin-proposal-function-bind"><a href="#babel-plugin-proposal-function-bind" class="headerlink" title="@babel/plugin-proposal-function-bind"></a><code>@babel/plugin-proposal-function-bind</code></h4><p>该插件可以让你轻松的为某个方法绑定this</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.loginId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    loginId: <span class="string">"abc"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj::Print(); <span class="comment">//相当于：Print.call(obj);</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>遗憾的是，目前vscode无法识别该语法，会在代码中报错，虽然并不会有什么实际性的危害，但是影响观感</p>
</blockquote>
<h4 id="babel-plugin-proposal-optional-chaining"><a href="#babel-plugin-proposal-optional-chaining" class="headerlink" title="@babel/plugin-proposal-optional-chaining"></a><code>@babel/plugin-proposal-optional-chaining</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    bar: &#123;</span><br><span class="line">      baz: <span class="number">42</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = obj?.foo?.bar?.baz; <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> safe = obj?.qux?.baz; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h4 id="babel-plugin-transform-remove-console"><a href="#babel-plugin-transform-remove-console" class="headerlink" title="babel-plugin-transform-remove-console"></a><code>babel-plugin-transform-remove-console</code></h4><p>该插件会移除源码中的控制台输出语句</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">"bar"</span>);</span><br></pre></td></tr></table></figure>
<p>编译后</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="babel-plugin-transform-runtime"><a href="#babel-plugin-transform-runtime" class="headerlink" title="@babel/plugin-transform-runtime"></a><code>@babel/plugin-transform-runtime</code></h4><p>用于提供一些公共的API，这些API会帮助代码转换</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="性能优化概述"><a href="#性能优化概述" class="headerlink" title="性能优化概述"></a>性能优化概述</h3><p>本章所讲的性能优化主要体现在三个方面：</p>
<div><br><img src="/2020/03/06/JavaScript-webpack/2020-02-12-09-53-01.png" width="400"><br></div>

<p><strong>构建性能</strong></p>
<p>这里所说的构建性能，是指在<strong>开发阶段的构建性能</strong>，而不是生产环境的构建性能</p>
<p>优化的目标，<strong>是降低从打包开始，到代码效果呈现所经过的时间</strong></p>
<p>构建性能会影响开发效率。构建性能越高，开发过程中时间的浪费越少</p>
<p><strong>传输性能</strong></p>
<p>传输性能是指，打包后的JS代码传输到浏览器经过的时间</p>
<p>在优化传输性能时要考虑到：</p>
<ol>
<li>总传输量：所有需要传输的JS文件的内容加起来，就是总传输量，重复代码越少，总传输量越少</li>
<li>文件数量：当访问页面时，需要传输的JS文件数量，文件数量越多，http请求越多，响应速度越慢</li>
<li>浏览器缓存：JS文件会被浏览器缓存，被缓存的文件不会再进行传输</li>
</ol>
<p><strong>运行性能</strong></p>
<p>运行性能是指，JS代码在浏览器端的运行速度</p>
<p>它主要取决于我们如何书写高性能的代码</p>
<p><strong>永远不要过早的关注于性能</strong>，因为你在开发的时候，无法完全预知最终的运行性能，过早的关注性能会极大的降低开发效率</p>
<hr>
<p>性能优化主要从上面三个维度入手</p>
<p><strong>性能优化没有完美的解决方案，需要具体情况具体分析</strong></p>
<h3 id="减少模块解析-构建"><a href="#减少模块解析-构建" class="headerlink" title="减少模块解析(构建)"></a>减少模块解析(构建)</h3><ul>
<li>什么叫做模块解析？</li>
</ul>
<p><img src="/2020/03/06/JavaScript-webpack/2020-02-13-16-26-41.png" alt></p>
<p>模块解析包括：抽象语法树分析、依赖分析、模块语法替换</p>
<ul>
<li>不做模块解析会怎样？</li>
</ul>
<p><img src="/2020/03/06/JavaScript-webpack/2020-02-13-16-28-10.png" alt></p>
<p>如果某个模块不做解析，该模块经过loader处理后的代码就是最终代码。</p>
<p>如果没有loader对该模块进行处理，该模块的源码就是最终打包结果的代码。</p>
<p>如果不对某个模块进行解析，可以缩短构建时间</p>
<ul>
<li>哪些模块不需要解析？</li>
</ul>
<p>模块中无其他依赖：一些已经打包好的第三方库，比如jquery</p>
<ul>
<li>如何让某个模块不要解析？</li>
</ul>
<p>配置<code>module.noParse</code>，它是一个正则，被正则匹配到的模块不会解析</p>
<h3 id="优化loader性能-构建"><a href="#优化loader性能-构建" class="headerlink" title="优化loader性能(构建)"></a>优化loader性能(构建)</h3><ul>
<li>进一步限制loader的应用范围</li>
</ul>
<p>思路是：对于某些库，不使用loader</p>
<p>例如：babel-loader可以转换ES6或更高版本的语法，可是有些库本身就是用ES5语法书写的，不需要转换，使用babel-loader反而会浪费构建时间</p>
<p>lodash就是这样的一个库</p>
<blockquote>
<p>lodash是在ES5之前出现的库，使用的是ES3语法</p>
</blockquote>
<p>通过<code>module.rule.exclude</code>或<code>module.rule.include</code>，排除或仅包含需要应用loader的场景</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                exclude: <span class="regexp">/lodash/</span>,</span><br><span class="line">                use: <span class="string">"babel-loader"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果暴力一点，甚至可以排除掉<code>node_modules</code>目录中的模块，或仅转换<code>src</code>目录的模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                <span class="comment">//或</span></span><br><span class="line">                <span class="comment">// include: /src/,</span></span><br><span class="line">                use: <span class="string">"babel-loader"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种做法是对loader的范围进行进一步的限制，和noParse不冲突，想想看，为什么不冲突</p>
</blockquote>
<ul>
<li>缓存loader的结果</li>
</ul>
<p>我们可以基于一种假设：如果某个文件内容不变，经过相同的loader解析后，解析后的结果也不变</p>
<p>于是，可以将loader的解析结果保存下来，让后续的解析直接使用保存的结果</p>
<p><code>cache-loader</code>可以实现这样的功能</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [<span class="string">'cache-loader'</span>, ...loaders]</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有趣的是，<code>cache-loader</code>放到最前面，却能够决定后续的loader是否运行</p>
<p>实际上，loader的运行过程中，还包含一个过程，即<code>pitch</code></p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-02-21-13-32-36.png" alt></p>
<p><code>cache-loader</code>还可以实现各自自定义的配置，具体方式见文档</p>
<ul>
<li>为loader的运行开启多线程</li>
</ul>
<p><code>thread-loader</code>会开启一个线程池，线程池中包含适量的线程</p>
<p>它会把后续的loader放到线程池的线程中运行，以提高构建效率</p>
<p>由于后续的loader会放到新的线程中，所以，后续的loader不能：</p>
<ul>
<li>使用 webpack api 生成文件</li>
<li>无法使用自定义的 plugin api</li>
<li>无法访问 webpack options</li>
</ul>
<blockquote>
<p>在实际的开发中，可以进行测试，来决定<code>thread-loader</code>放到什么位置</p>
</blockquote>
<p><strong>特别注意</strong>，开启和管理线程需要消耗时间，在小型项目中使用<code>thread-loader</code>反而会增加构建时间</p>
<h3 id="热替换-HMR-构建"><a href="#热替换-HMR-构建" class="headerlink" title="热替换 HMR(构建)"></a>热替换 HMR(构建)</h3><blockquote>
<p>热替换并不能降低构建时间（可能还会稍微增加），但可以降低代码改动到效果呈现的时间</p>
</blockquote>
<p>当使用<code>webpack-dev-server</code>时，考虑代码改动到效果呈现的过程</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-02-21-14-20-49.png" alt="|400"></p>
<p>而使用了热替换后，流程发生了变化</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-02-21-14-22-32.png" alt="|400"></p>
<h4 id="使用和原理"><a href="#使用和原理" class="headerlink" title="使用和原理"></a>使用和原理</h4><ol>
<li>更改配置</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer:&#123;</span><br><span class="line">    hot:<span class="literal">true</span> <span class="comment">// 开启HMR</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:[ </span><br><span class="line">    <span class="comment">// 可选</span></span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>更改代码</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">module</span>.hot)&#123; <span class="comment">// 是否开启了热更新</span></span><br><span class="line">  <span class="built_in">module</span>.hot.accept() <span class="comment">// 接受热更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，这段代码会参与最终运行！</p>
<p>当开启了热更新后，<code>webpack-dev-server</code>会向打包结果中注入<code>module.hot</code>属性</p>
<p>默认情况下，<code>webpack-dev-server</code>不管是否开启了热更新，当重新打包后，都会调用<code>location.reload</code>刷新页面</p>
<p>但如果运行了<code>module.hot.accept()</code>，将改变这一行为</p>
<p><code>module.hot.accept()</code>的作用是让<code>webpack-dev-server</code>通过<code>socket</code>管道，把服务器更新的内容发送到浏览器</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-02-21-14-34-05.png" alt="|300"></p>
<p>然后，将结果交给插件<code>HotModuleReplacementPlugin</code>注入的代码执行</p>
<p>插件<code>HotModuleReplacementPlugin</code>会根据覆盖原始代码，然后让代码重新执行</p>
<p><strong>所以，热替换发生在代码运行期</strong></p>
<h4 id="样式热替换"><a href="#样式热替换" class="headerlink" title="样式热替换"></a>样式热替换</h4><p>对于样式也是可以使用热替换的，但需要使用<code>style-loader</code></p>
<p>因为热替换发生时，<code>HotModuleReplacementPlugin</code>只会简单的重新运行模块代码</p>
<p>因此<code>style-loader</code>的代码一运行，就会重新设置<code>style</code>元素中的样式</p>
<p>而<code>mini-css-extract-plugin</code>，由于它生成文件是在<strong>构建期间</strong>，运行期间并会也无法改动文件，因此它对于热替换是无效的</p>
<h3 id="手动分包-传输"><a href="#手动分包-传输" class="headerlink" title="手动分包(传输)"></a>手动分包(传输)</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>手动分包的总体思路是：</p>
<ol>
<li>先单独的打包公共模块</li>
</ol>
<p><img src="/2020/03/06/JavaScript-webpack/2020-02-24-13-24-57.png" alt="单独打包公共模块"></p>
<p>公共模块会被打包成为动态链接库(dll Dynamic Link Library)，并生成资源清单</p>
<ol start="2">
<li>根据入口模块进行正常打包</li>
</ol>
<p>打包时，如果发现模块中使用了资源清单中描述的模块，则不会形成下面的代码结构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码，入口文件index.js</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">"jquery"</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">"lodash"</span></span><br><span class="line">_.isArray($(<span class="string">".red"</span>));</span><br></pre></td></tr></table></figure>
<p>由于资源清单中包含<code>jquery</code>和<code>lodash</code>两个模块，因此打包结果的大致格式是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;)(&#123;</span><br><span class="line">  <span class="comment">// index.js文件的打包结果并没有变化</span></span><br><span class="line">  <span class="string">"./src/index.js"</span>:</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">module, exports, __webpack_require__</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $ = __webpack_require__(<span class="string">"./node_modules/jquery/index.js"</span>)</span><br><span class="line">    <span class="keyword">var</span> _ = __webpack_require__(<span class="string">"./node_modules/lodash/index.js"</span>)</span><br><span class="line">    _.isArray($(<span class="string">".red"</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 由于资源清单中存在，jquery的代码并不会出现在这里</span></span><br><span class="line">  <span class="string">"./node_modules/jquery/index.js"</span>:</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">module, exports, __webpack_require__</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = jquery;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 由于资源清单中存在，lodash的代码并不会出现在这里</span></span><br><span class="line">  <span class="string">"./node_modules/lodash/index.js"</span>:</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">module, exports, __webpack_require__</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = lodash;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="打包公共模块"><a href="#打包公共模块" class="headerlink" title="打包公共模块"></a>打包公共模块</h4><p>打包公共模块是一个<strong>独立的</strong>打包过程</p>
<ol>
<li>单独打包公共模块，暴露变量名</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.dll.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">"production"</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    jquery: [<span class="string">"jquery"</span>],</span><br><span class="line">    lodash: [<span class="string">"lodash"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"dll/[name].js"</span>,</span><br><span class="line">    library: <span class="string">"[name]"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>利用<code>DllPlugin</code>生成资源清单</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.dll.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      path: path.resolve(__dirname, <span class="string">"dll"</span>, <span class="string">"[name].manifest.json"</span>), <span class="comment">//资源清单的保存位置</span></span><br><span class="line">      name: <span class="string">"[name]"</span><span class="comment">//资源清单中，暴露的变量名</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行后，即可完成公共模块打包</p>
<h4 id="使用公共模块"><a href="#使用公共模块" class="headerlink" title="使用公共模块"></a>使用公共模块</h4><ol>
<li>在页面中手动引入公共模块</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dll/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dll/lodash.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>重新设置<code>clean-webpack-plugin</code></li>
</ol>
<p>如果使用了插件<code>clean-webpack-plugin</code>，为了避免它把公共模块清除，需要做出以下配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">  <span class="comment">// 要清除的文件或目录</span></span><br><span class="line">  <span class="comment">// 排除掉dll目录本身和它里面的文件</span></span><br><span class="line">  cleanOnceBeforeBuildPatterns: [<span class="string">"**/*"</span>, <span class="string">'!dll'</span>, <span class="string">'!dll/*'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>目录和文件的匹配规则使用的是<a href="https://github.com/sindresorhus/globby#globbing-patterns" target="_blank" rel="noopener">globbing patterns</a></p>
</blockquote>
<ol start="3">
<li>使用<code>DllReferencePlugin</code>控制打包结果</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">      manifest: <span class="built_in">require</span>(<span class="string">"./dll/jquery.manifest.json"</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">      manifest: <span class="built_in">require</span>(<span class="string">"./dll/lodash.manifest.json"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>手动打包的过程</strong>：</p>
<ol>
<li>开启<code>output.library</code>暴露公共模块</li>
<li>用<code>DllPlugin</code>创建资源清单</li>
<li>用<code>DllReferencePlugin</code>使用资源清单</li>
</ol>
<p><strong>手动打包的注意事项</strong>：</p>
<ol>
<li>资源清单不参与运行，可以不放到打包目录中</li>
<li>记得手动引入公共JS，以及避免被删除</li>
<li>不要对小型的公共JS库使用</li>
</ol>
<p><strong>优点</strong>：</p>
<ol>
<li>极大提升自身模块的打包速度</li>
<li>极大的缩小了自身文件体积</li>
<li>有利于浏览器缓存第三方库的公共代码</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>使用非常繁琐</li>
<li>如果第三方库中包含重复代码，则效果不太理想</li>
</ol>
<h3 id="自动分包-传输"><a href="#自动分包-传输" class="headerlink" title="自动分包(传输)"></a>自动分包(传输)</h3><h4 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h4><p>不同与手动分包，自动分包是从<strong>实际的角度</strong>出发，从一个更加<strong>宏观的角度</strong>来控制分包，而一般不对具体哪个包要分出去进行控制</p>
<p>因此使用自动分包，不仅非常方便，而且更加贴合实际的开发需要</p>
<p>要控制自动分包，关键是要配置一个合理的<strong>分包策略</strong></p>
<p>有了分包策略之后，不需要额外安装任何插件，webpack会自动的按照策略进行分包</p>
<blockquote>
<p>实际上，webpack在内部是使用<code>SplitChunksPlugin</code>进行分包的<br>过去有一个库<code>CommonsChunkPlugin</code>也可以实现分包，不过由于该库某些地方并不完善，到了<code>webpack4</code>之后，已被<code>SplitChunksPlugin</code>取代</p>
</blockquote>
<p><img src="/2020/03/06/JavaScript-webpack/2020-02-24-17-19-47.png" alt="分包简单流程"></p>
<p>从分包流程中至少可以看出以下几点：</p>
<ul>
<li>分包策略至关重要，它决定了如何分包</li>
<li>分包时，webpack开启了一个<strong>新的chunk</strong>，对分离的模块进行打包</li>
<li>打包结果中，公共的部分被提取出来形成了一个单独的文件，它是新chunk的产物</li>
</ul>
<h4 id="分包策略的基本配置"><a href="#分包策略的基本配置" class="headerlink" title="分包策略的基本配置"></a>分包策略的基本配置</h4><p>webpack提供了<code>optimization</code>配置项，用于配置一些优化信息</p>
<p>其中<code>splitChunks</code>是分包策略的配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      <span class="comment">// 分包策略</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，分包策略有其默认的配置，我们只需要轻微的改动，即可应对大部分分包场景</p>
<ol>
<li>chunks</li>
</ol>
<p>该配置项用于配置需要应用分包策略的chunk</p>
<p>我们知道，分包是从已有的chunk中分离出新的chunk，那么哪些chunk需要分离呢</p>
<p>chunks有三个取值，分别是：</p>
<ul>
<li>all: 对于所有的chunk都要应用分包策略</li>
<li>async：【默认】仅针对异步chunk应用分包策略</li>
<li>initial：仅针对普通chunk应用分包策略</li>
</ul>
<p>所以，你只需要配置<code>chunks</code>为<code>all</code>即可</p>
<ol start="2">
<li>maxSize</li>
</ol>
<p>该配置可以控制包的最大字节数</p>
<p>如果某个包（包括分出来的包）超过了该值，则webpack会尽可能的将其分离成多个包</p>
<p>但是不要忽略的是，分包的<strong>基础单位是模块</strong>，如果一个完整的模块超过了该体积，它是无法做到再切割的，因此，尽管使用了这个配置，完全有可能某个包还是会超过这个体积</p>
<p>另外，该配置看上去很美妙，实际意义其实不大</p>
<p>因为分包的目的是<strong>提取大量的公共代码</strong>，从而减少总体积和充分利用浏览器缓存</p>
<p>虽然该配置可以把一些包进行再切分，但是实际的总体积和传输量并没有发生变化</p>
<blockquote>
<p>如果要进一步减少公共模块的体积，只能是压缩和<code>tree shaking</code></p>
</blockquote>
<h4 id="分包策略的其他配置"><a href="#分包策略的其他配置" class="headerlink" title="分包策略的其他配置"></a>分包策略的其他配置</h4><p>如果不想使用其他配置的默认值，可以手动进行配置：</p>
<ul>
<li>automaticNameDelimiter：新chunk名称的分隔符，默认值~</li>
<li>minChunks：一个模块被多少个chunk使用时，才会进行分包，默认值1</li>
<li>minSize：当分包达到多少字节后才允许被真正的拆分，默认值30000</li>
</ul>
<h4 id="缓存组"><a href="#缓存组" class="headerlink" title="缓存组"></a>缓存组</h4><p>之前配置的分包策略是全局的</p>
<p>而实际上，分包策略是基于缓存组的</p>
<p>每个缓存组提供一套独有的策略，webpack按照缓存组的优先级依次处理每个缓存组，被缓存组处理过的分包不需要再次分包</p>
<p>默认情况下，webpack提供了两个缓存组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization:&#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      <span class="comment">//全局配置</span></span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        <span class="comment">// 属性名是缓存组名称，会影响到分包的chunk名</span></span><br><span class="line">        <span class="comment">// 属性值是缓存组的配置，缓存组继承所有的全局配置，也有自己特殊的配置</span></span><br><span class="line">        vendors: &#123; </span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>, <span class="comment">// 当匹配到相应模块时，将这些模块进行单独打包</span></span><br><span class="line">          priority: <span class="number">-10</span> <span class="comment">// 缓存组优先级，优先级越高，该策略越先进行处理，默认值为0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          minChunks: <span class="number">2</span>,  <span class="comment">// 覆盖全局配置，将最小chunk引用数改为2</span></span><br><span class="line">          priority: <span class="number">-20</span>, <span class="comment">// 优先级</span></span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span> <span class="comment">// 重用已经被分离出去的chunk</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很多时候，缓存组对于我们来说没什么意义，因为默认的缓存组就已经够用了</p>
<p>但是我们同样可以利用缓存组来完成一些事情，比如对公共样式的抽离</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">"all"</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        styles: &#123;</span><br><span class="line">          test: <span class="regexp">/\.css$/</span>, <span class="comment">// 匹配样式模块</span></span><br><span class="line">          minSize: <span class="number">0</span>, <span class="comment">// 覆盖默认的最小尺寸，这里仅仅是作为测试</span></span><br><span class="line">          minChunks: <span class="number">2</span> <span class="comment">// 覆盖默认的最小chunk引用数</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [MiniCssExtractPlugin.loader, <span class="string">"css-loader"</span>] &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">"./public/index.html"</span>,</span><br><span class="line">      chunks: [<span class="string">"index"</span>]</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">"[name].[hash:5].css"</span>,</span><br><span class="line">      <span class="comment">// chunkFilename是配置来自于分割chunk的文件名</span></span><br><span class="line">      chunkFilename: <span class="string">"common.[hash:5].css"</span> </span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="配合多页应用"><a href="#配合多页应用" class="headerlink" title="配合多页应用"></a>配合多页应用</h4><p>虽然现在单页应用是主流，但免不了还是会遇到多页应用</p>
<p>由于在多页应用中需要为每个html页面指定需要的chunk，这就造成了问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  template: <span class="string">"./public/index.html"</span>,</span><br><span class="line">  chunks: [<span class="string">"index~other"</span>, <span class="string">"vendors~index~other"</span>, <span class="string">"index"</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们必须手动的指定被分离出去的chunk名称，这不是一种好办法</p>
<p>幸好<code>html-webpack-plugin</code>的新版本中解决了这一问题</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D html-webpack-plugin@next</span><br></pre></td></tr></table></figure>
<p>做出以下配置即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  template: <span class="string">"./public/index.html"</span>,</span><br><span class="line">  chunks: [<span class="string">"index"</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>它会自动的找到被<code>index</code>分离出去的chunk，并完成引用</p>
<blockquote>
<p>目前这个版本仍处于测试解决，还未正式发布</p>
</blockquote>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>自动分包的原理其实并不复杂，主要经过以下步骤：</p>
<ol>
<li>检查每个chunk编译的结果</li>
<li>根据分包策略，找到那些满足策略的模块</li>
<li>根据分包策略，生成新的chunk打包这些模块（代码有所变化）</li>
<li>把打包出去的模块从原始包中移除，并修正原始包代码</li>
</ol>
<p>在代码层面，有以下变动</p>
<ol>
<li>分包的代码中，加入一个全局变量，类型为数组，其中包含公共模块的代码</li>
<li>原始包的代码中，使用数组中的公共代码</li>
</ol>
<h3 id="代码压缩-传输"><a href="#代码压缩-传输" class="headerlink" title="代码压缩(传输)"></a>代码压缩(传输)</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ol>
<li><strong>为什么要进行代码压缩</strong></li>
</ol>
<p>减少代码体积；破坏代码的可读性，提升破解成本；</p>
<ol start="2">
<li><strong>什么时候要进行代码压缩</strong></li>
</ol>
<p>生产环境</p>
<ol start="3">
<li><strong>使用什么压缩工具</strong></li>
</ol>
<p>目前最流行的代码压缩工具主要有两个：<code>UglifyJs</code>和<code>Terser</code></p>
<p><code>UglifyJs</code>是一个传统的代码压缩工具，已存在多年，曾经是前端应用的必备工具，但由于它不支持<code>ES6</code>语法，所以目前的流行度已有所下降。</p>
<p><code>Terser</code>是一个新起的代码压缩工具，支持<code>ES6+</code>语法，因此被很多构建工具内置使用。<code>webpack</code>安装后会内置<code>Terser</code>，当启用生产环境后即可用其进行代码压缩。</p>
<p>因此，我们选择<code>Terser</code></p>
<p><strong>关于副作用 side effect</strong></p>
<p>副作用：函数运行过程中，可能会对外部环境造成影响的功能</p>
<p>如果函数中包含以下代码，该函数叫做副作用函数:</p>
<ul>
<li>异步代码</li>
<li>localStorage</li>
<li>对外部数据的修改</li>
</ul>
<p>如果一个函数没有副作用，同时，函数的返回结果仅依赖参数，则该函数叫做纯函数(pure function)</p>
<h4 id="Terser"><a href="#Terser" class="headerlink" title="Terser"></a>Terser</h4><p>在<code>Terser</code>的官网可尝试它的压缩效果</p>
<blockquote>
<p>Terser官网：<a href="https://terser.org/" target="_blank" rel="noopener">https://terser.org/</a></p>
</blockquote>
<h4 id="webpack-Terser"><a href="#webpack-Terser" class="headerlink" title="webpack+Terser"></a>webpack+Terser</h4><p>webpack自动集成了Terser</p>
<p>如果你想更改、添加压缩工具，又或者是想对Terser进行配置，使用下面的webpack配置即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    <span class="comment">// 是否要启用压缩，默认情况下，生产环境会自动开启</span></span><br><span class="line">    minimize: <span class="literal">true</span>, </span><br><span class="line">    minimizer: [ <span class="comment">// 压缩时使用的插件，可以有多个</span></span><br><span class="line">      <span class="keyword">new</span> TerserPlugin(), </span><br><span class="line">      <span class="keyword">new</span> OptimizeCSSAssetsPlugin()</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="tree-shaking-传输"><a href="#tree-shaking-传输" class="headerlink" title="tree shaking(传输)"></a>tree shaking(传输)</h3><blockquote>
<p>压缩可以移除模块内部的无效代码<br>tree shaking 可以移除模块之间的无效代码</p>
</blockquote>
<p><img src="/2020/03/06/JavaScript-webpack/160bfdcf2a31ce4a" alt></p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>某些模块导出的代码并不一定会被用到</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myMath.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"add"</span>)</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"sub"</span>)</span><br><span class="line">  <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;add&#125; <span class="keyword">from</span> <span class="string">"./myMath"</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>tree shaking 用于移除掉不会用到的导出</p>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p><code>webpack2</code>开始就支持了<code>tree shaking</code></p>
<p>只要是生产环境，<code>tree shaking</code>自动开启</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>webpack会从入口模块出发寻找依赖关系</p>
<p>当解析一个模块时，webpack会根据ES6的模块导入语句来判断，该模块依赖了另一个模块的哪个导出</p>
<p>webpack之所以选择ES6的模块导入语句，是因为ES6模块有以下特点：</p>
<ol>
<li>导入导出语句只能是顶层语句</li>
<li>import的模块名只能是字符串常量</li>
<li>import绑定的变量是不可变的</li>
</ol>
<p>这些特征都非常有利于分析出稳定的依赖</p>
<p>在具体分析依赖时，webpack坚持的原则是：<strong>保证代码正常运行，然后再尽量tree shaking</strong></p>
<p>所以，如果你依赖的是一个导出的对象，由于JS语言的动态特性，以及<code>webpack</code>还不够智能，为了保证代码正常运行，它不会移除对象中的任何信息</p>
<p>因此，我们在编写代码的时候，<strong>尽量</strong>：</p>
<ul>
<li>使用<code>export xxx</code>导出，而不使用<code>export default {xxx}</code>导出</li>
<li>使用<code>import {xxx} from &quot;xxx&quot;</code>导入，而不使用<code>import xxx from &quot;xxx&quot;</code>导入</li>
</ul>
<p>依赖分析完毕后，<code>webpack</code>会根据每个模块每个导出是否被使用，标记其他导出为<code>dead code</code>，然后交给代码压缩工具处理</p>
<p>代码压缩工具最终移除掉那些<code>dead code</code>代码</p>
<h4 id="使用第三方库"><a href="#使用第三方库" class="headerlink" title="使用第三方库"></a>使用第三方库</h4><p>某些第三方库可能使用的是<code>commonjs</code>的方式导出，比如<code>lodash</code></p>
<p>又或者没有提供普通的ES6方式导出</p>
<p>对于这些库，<code>tree shaking</code>是无法发挥作用的</p>
<p>因此要寻找这些库的<code>es6</code>版本，好在很多流行但没有使用的<code>ES6</code>的第三方库，都发布了它的<code>ES6</code>版本，比如<code>lodash-es</code></p>
<h4 id="作用域分析"><a href="#作用域分析" class="headerlink" title="作用域分析"></a>作用域分析</h4><p><code>tree shaking</code>本身并没有完善的作用域分析，可能导致在一些<code>dead code</code>函数中的依赖仍然会被视为依赖</p>
<p>插件<code>webpack-deep-scope-plugin</code>提供了作用域分析，可解决这些问题</p>
<h4 id="副作用问题"><a href="#副作用问题" class="headerlink" title="副作用问题"></a>副作用问题</h4><p>webpack在<code>tree shaking</code>的使用，有一个原则：<strong>一定要保证代码正确运行</strong></p>
<p>在满足该原则的基础上，再来决定如何<code>tree shaking</code></p>
<p>因此，当<code>webpack</code>无法确定某个模块是否有副作用时，它往往将其视为有副作用</p>
<p>因此，某些情况可能并不是我们所想要的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//common.js</span></span><br><span class="line"><span class="keyword">var</span> n  = <span class="built_in">Math</span>.random();</span><br><span class="line"></span><br><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"./common.js"</span></span><br></pre></td></tr></table></figure>
<p>虽然我们根本没用有<code>common.js</code>的导出，但<code>webpack</code>担心<code>common.js</code>有副作用，如果去掉会影响某些功能</p>
<p>如果要解决该问题，就需要标记该文件是没有副作用的</p>
<p>在<code>package.json</code>中加入<code>sideEffects</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"sideEffects"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有两种配置方式：</p>
<ul>
<li>false：当前工程中，所有模块都没有副作用。注意，这种写法会影响到某些css文件的导入</li>
<li>数组：设置哪些文件拥有副作用，例如：<code>[&quot;!src/common.js&quot;]</code>，表示只要不是<code>src/common.js</code>的文件，都有副作用</li>
</ul>
<blockquote>
<p>这种方式我们一般不处理，通常是一些第三方库在它们自己的<code>package.json</code>中标注</p>
</blockquote>
<h4 id="css-tree-shaking"><a href="#css-tree-shaking" class="headerlink" title="css tree shaking"></a>css tree shaking</h4><p><code>webpack</code>无法对<code>css</code>完成<code>tree shaking</code>，因为<code>css</code>跟<code>es6</code>没有半毛钱关系</p>
<p>因此对<code>css</code>的<code>tree shaking</code>需要其他插件完成</p>
<p>例如：<code>purgecss-webpack-plugin</code></p>
<blockquote>
<p>注意：<code>purgecss-webpack-plugin</code>对<code>css module</code>无能为力</p>
</blockquote>
<h3 id="ESLint-代码风格"><a href="#ESLint-代码风格" class="headerlink" title="ESLint(代码风格)"></a>ESLint(代码风格)</h3><p>ESLint是一个针对JS的代码风格<strong>检查</strong>工具，当不满足其要求的风格时，会给予警告或错误</p>
<p>官网：<a href="https://eslint.org/" target="_blank" rel="noopener">https://eslint.org/</a></p>
<p>民间中文网：<a href="https://eslint.bootcss.com/" target="_blank" rel="noopener">https://eslint.bootcss.com/</a></p>
<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>ESLint通常配合编辑器使用</p>
<ol>
<li>在vscode中安装<code>ESLint</code></li>
</ol>
<p>该工具会自动检查工程中的JS文件</p>
<p>检查的工作交给<code>eslint</code>库，如果当前工程没有，则会去全局库中查找，如果都没有，则无法完成检查</p>
<p>另外，检查的依据是<code>eslint</code>的配置文件<code>.eslintrc</code>，如果找不到工程中的配置文件，也无法完成检查</p>
<ol start="2">
<li>安装<code>eslint</code></li>
</ol>
<p><code>npm i [-g] eslint</code></p>
<ol start="3">
<li>创建配置文件</li>
</ol>
<p>可以通过<code>eslint</code>交互式命令创建配置文件</p>
<blockquote>
<p>由于windows环境中git窗口对交互式命名支持不是很好，建议使用powershell</p>
</blockquote>
<p><code>npx eslint --init</code></p>
<blockquote>
<p>eslint会识别工程中的<code>.eslintrc.*</code>文件，也能够识别<code>package.json</code>中的<code>eslintConfig</code>字段</p>
</blockquote>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ol>
<li>env</li>
</ol>
<p>配置代码的运行环境</p>
<ul>
<li>browser：代码是否在浏览器环境中运行</li>
<li>es6：是否启用ES6的全局API，例如<code>Promise</code>等</li>
</ul>
<ol start="2">
<li>parserOptions</li>
</ol>
<p>该配置指定<code>eslint</code>对哪些语法的支持</p>
<ul>
<li>ecmaVersion: 支持的ES语法版本</li>
<li>sourceType<ul>
<li>script：传统脚本</li>
<li>module：模块化脚本</li>
</ul>
</li>
</ul>
<ol start="3">
<li>parser</li>
</ol>
<p><code>eslint</code>的工作原理是先将代码进行解析，然后按照规则进行分析</p>
<p><code>eslint</code> 默认使用<code>Espree</code>作为其解析器，你可以在配置文件中指定一个不同的解析器。</p>
<ol start="4">
<li>globals</li>
</ol>
<p>配置可以使用的额外的全局变量</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"globals"</span>: &#123;</span><br><span class="line">    <span class="attr">"var1"</span>: <span class="string">"readonly"</span>,</span><br><span class="line">    <span class="attr">"var2"</span>: <span class="string">"writable"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>eslint</code>支持注释形式的配置，在代码中使用下面的注释也可以完成配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* global var1, var2 */</span></span><br><span class="line"><span class="comment">/* global var3:writable, var4:writable */</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>extends</li>
</ol>
<p>该配置继承自哪里</p>
<p>它的值可以是字符串或者数组</p>
<p>比如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"extends"</span>: <span class="string">"eslint:recommended"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示，该配置缺失的位置，使用<code>eslint</code>推荐的规则</p>
<ol start="6">
<li>ignoreFiles</li>
</ol>
<p>排除掉某些不需要验证的文件</p>
<p><code>.eslintignore</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dist/**/*.js</span><br><span class="line">node_modules</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>rules</li>
</ol>
<p><code>eslint</code>规则集</p>
<p>每条规则影响某个方面的代码风格</p>
<p>每条规则都有下面几个取值：</p>
<ul>
<li>off 或 0 或 false: 关闭该规则的检查</li>
<li>warn 或 1 或 true：警告，不会导致程序退出</li>
<li>error 或 2：错误，当被触发的时候，程序会退出</li>
</ul>
<p>除了在配置文件中使用规则外，还可以在注释中使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* eslint eqeqeq: "off", curly: "error" */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://eslint.bootcss.com/docs/rules/" target="_blank" rel="noopener">https://eslint.bootcss.com/docs/rules/</a></p>
</blockquote>
<h3 id="懒加载（传输）"><a href="#懒加载（传输）" class="headerlink" title="懒加载（传输）"></a>懒加载（传输）</h3><p><code>import()</code></p>
<h3 id="bundle-analyzer-budle分析"><a href="#bundle-analyzer-budle分析" class="headerlink" title="bundle analyzer(budle分析)"></a>bundle analyzer(budle分析)</h3><p>插件<code>webpack-bundle-analyzer</code></p>
<h3 id="gzip-传输"><a href="#gzip-传输" class="headerlink" title="gzip(传输)"></a>gzip(传输)</h3><p>gzip是一种压缩文件的算法</p>
<h4 id="B-S结构中的压缩传输"><a href="#B-S结构中的压缩传输" class="headerlink" title="B/S结构中的压缩传输"></a>B/S结构中的压缩传输</h4><p><img src="/2020/03/06/JavaScript-webpack/2020-02-28-15-37-26.png" alt></p>
<p>优点：传输效率可能得到大幅提升</p>
<p>缺点：服务器的压缩需要时间，客户端的解压需要时间</p>
<h4 id="使用webpack进行预压缩"><a href="#使用webpack进行预压缩" class="headerlink" title="使用webpack进行预压缩"></a>使用webpack进行预压缩</h4><p>使用<code>compression-webpack-plugin</code>插件对打包结果进行预压缩，可以移除服务器的压缩时间</p>
<p><img src="/2020/03/06/JavaScript-webpack/2020-02-28-15-41-44.png" alt></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JavaScript/">JavaScript</a><a href="/tags/webpack/">webpack</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2020/03/06/JavaScript-webpack/" data-title="JavaScript-webpack | 110laile" data-tsina class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev">
 <a href="/2020/03/16/设计模式-基础知识/" title="设计模式-基础知识">
  <strong>上一篇：</strong><br>
  <span>
  设计模式-基础知识</span>
</a>
</div>


<div class="next">
<a href="/2020/03/03/JavaScript-包管理/" title="JavaScript-包管理">
 <strong>下一篇：</strong><br> 
 <span>JavaScript-包管理
</span>
</a>
</div>

</nav>

	



</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器模块化带来的问题"><span class="toc-number">1.</span> <span class="toc-text">浏览器模块化带来的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#根本原因"><span class="toc-number">1.1.</span> <span class="toc-text">根本原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决办法"><span class="toc-number">1.2.</span> <span class="toc-text">解决办法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见的构建工具"><span class="toc-number">2.</span> <span class="toc-text">常见的构建工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack核心"><span class="toc-number">3.</span> <span class="toc-text">webpack核心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#安装"><span class="toc-number">3.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用"><span class="toc-number">3.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模块化兼容性"><span class="toc-number">3.3.</span> <span class="toc-text">模块化兼容性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编译结果分析"><span class="toc-number">3.4.</span> <span class="toc-text">编译结果分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编译过程"><span class="toc-number">3.5.</span> <span class="toc-text">编译过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化"><span class="toc-number">3.5.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编译"><span class="toc-number">3.5.2.</span> <span class="toc-text">编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#输出"><span class="toc-number">3.5.3.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总过程"><span class="toc-number">3.5.4.</span> <span class="toc-text">总过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置文件"><span class="toc-number">3.6.</span> <span class="toc-text">配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mode配置"><span class="toc-number">3.6.1.</span> <span class="toc-text">mode配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#devtool配置"><span class="toc-number">3.6.2.</span> <span class="toc-text">devtool配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#入口和出口"><span class="toc-number">3.6.3.</span> <span class="toc-text">入口和出口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#loader"><span class="toc-number">3.6.4.</span> <span class="toc-text">loader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#plugin"><span class="toc-number">3.6.5.</span> <span class="toc-text">plugin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他细节配置"><span class="toc-number">3.6.6.</span> <span class="toc-text">其他细节配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用扩展"><span class="toc-number">3.7.</span> <span class="toc-text">常用扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack内置插件"><span class="toc-number">3.8.</span> <span class="toc-text">webpack内置插件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css工程化"><span class="toc-number">4.</span> <span class="toc-text">css工程化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#css工程化概述"><span class="toc-number">4.1.</span> <span class="toc-text">css工程化概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#css的问题"><span class="toc-number">4.1.1.</span> <span class="toc-text">css的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何解决"><span class="toc-number">4.1.2.</span> <span class="toc-text">如何解决</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用webapck拆分css"><span class="toc-number">4.2.</span> <span class="toc-text">利用webapck拆分css</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BEM-解决类名冲突"><span class="toc-number">4.3.</span> <span class="toc-text">BEM(解决类名冲突)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css-in-js-解决类名冲突"><span class="toc-number">4.4.</span> <span class="toc-text">css in js(解决类名冲突)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css-module-解决类名冲突问题"><span class="toc-number">4.5.</span> <span class="toc-text">css module(解决类名冲突问题)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#预编译器less-解决重复样式问题"><span class="toc-number">4.6.</span> <span class="toc-text">预编译器less(解决重复样式问题)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PostCss"><span class="toc-number">4.7.</span> <span class="toc-text">PostCss</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽离css文件"><span class="toc-number">4.8.</span> <span class="toc-text">抽离css文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js兼容性"><span class="toc-number">5.</span> <span class="toc-text">js兼容性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#babel的安装和使用"><span class="toc-number">5.1.</span> <span class="toc-text">babel的安装和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#babel简介"><span class="toc-number">5.1.1.</span> <span class="toc-text">babel简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babel的安装"><span class="toc-number">5.1.2.</span> <span class="toc-text">babel的安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babel的使用"><span class="toc-number">5.1.3.</span> <span class="toc-text">babel的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babel的配置"><span class="toc-number">5.1.4.</span> <span class="toc-text">babel的配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#babel预设"><span class="toc-number">5.2.</span> <span class="toc-text">babel预设</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#babel插件"><span class="toc-number">5.3.</span> <span class="toc-text">babel插件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#babel-plugin-proposal-class-properties"><span class="toc-number">5.3.1.</span> <span class="toc-text">@babel/plugin-proposal-class-properties</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babel-plugin-proposal-function-bind"><span class="toc-number">5.3.2.</span> <span class="toc-text">@babel/plugin-proposal-function-bind</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babel-plugin-proposal-optional-chaining"><span class="toc-number">5.3.3.</span> <span class="toc-text">@babel/plugin-proposal-optional-chaining</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babel-plugin-transform-remove-console"><span class="toc-number">5.3.4.</span> <span class="toc-text">babel-plugin-transform-remove-console</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babel-plugin-transform-runtime"><span class="toc-number">5.3.5.</span> <span class="toc-text">@babel/plugin-transform-runtime</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能优化"><span class="toc-number">6.</span> <span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#性能优化概述"><span class="toc-number">6.1.</span> <span class="toc-text">性能优化概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#减少模块解析-构建"><span class="toc-number">6.2.</span> <span class="toc-text">减少模块解析(构建)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优化loader性能-构建"><span class="toc-number">6.3.</span> <span class="toc-text">优化loader性能(构建)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#热替换-HMR-构建"><span class="toc-number">6.4.</span> <span class="toc-text">热替换 HMR(构建)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用和原理"><span class="toc-number">6.4.1.</span> <span class="toc-text">使用和原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#样式热替换"><span class="toc-number">6.4.2.</span> <span class="toc-text">样式热替换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#手动分包-传输"><span class="toc-number">6.5.</span> <span class="toc-text">手动分包(传输)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本原理"><span class="toc-number">6.5.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#打包公共模块"><span class="toc-number">6.5.2.</span> <span class="toc-text">打包公共模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用公共模块"><span class="toc-number">6.5.3.</span> <span class="toc-text">使用公共模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">6.5.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动分包-传输"><span class="toc-number">6.6.</span> <span class="toc-text">自动分包(传输)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本原理-1"><span class="toc-number">6.6.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分包策略的基本配置"><span class="toc-number">6.6.2.</span> <span class="toc-text">分包策略的基本配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分包策略的其他配置"><span class="toc-number">6.6.3.</span> <span class="toc-text">分包策略的其他配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缓存组"><span class="toc-number">6.6.4.</span> <span class="toc-text">缓存组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配合多页应用"><span class="toc-number">6.6.5.</span> <span class="toc-text">配合多页应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原理"><span class="toc-number">6.6.6.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码压缩-传输"><span class="toc-number">6.7.</span> <span class="toc-text">代码压缩(传输)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#前言"><span class="toc-number">6.7.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Terser"><span class="toc-number">6.7.2.</span> <span class="toc-text">Terser</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webpack-Terser"><span class="toc-number">6.7.3.</span> <span class="toc-text">webpack+Terser</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tree-shaking-传输"><span class="toc-number">6.8.</span> <span class="toc-text">tree shaking(传输)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#背景"><span class="toc-number">6.8.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用-1"><span class="toc-number">6.8.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原理-1"><span class="toc-number">6.8.3.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用第三方库"><span class="toc-number">6.8.4.</span> <span class="toc-text">使用第三方库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#作用域分析"><span class="toc-number">6.8.5.</span> <span class="toc-text">作用域分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#副作用问题"><span class="toc-number">6.8.6.</span> <span class="toc-text">副作用问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css-tree-shaking"><span class="toc-number">6.8.7.</span> <span class="toc-text">css tree shaking</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ESLint-代码风格"><span class="toc-number">6.9.</span> <span class="toc-text">ESLint(代码风格)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用-2"><span class="toc-number">6.9.1.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置"><span class="toc-number">6.9.2.</span> <span class="toc-text">配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#懒加载（传输）"><span class="toc-number">6.10.</span> <span class="toc-text">懒加载（传输）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bundle-analyzer-budle分析"><span class="toc-number">6.11.</span> <span class="toc-text">bundle analyzer(budle分析)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gzip-传输"><span class="toc-number">6.12.</span> <span class="toc-text">gzip(传输)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#B-S结构中的压缩传输"><span class="toc-number">6.12.1.</span> <span class="toc-text">B/S结构中的压缩传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用webpack进行预压缩"><span class="toc-number">6.12.2.</span> <span class="toc-text">使用webpack进行预压缩</span></a></li></ol></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/NET/" title=".NET">.NET<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/Cmd/" title="Cmd">Cmd<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Css/" title="Css">Css<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Docker/" title="Docker">Docker<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Emmet/" title="Emmet">Emmet<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Git/" title="Git">Git<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/HTML/" title="HTML">HTML<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/JQuery/" title="JQuery">JQuery<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript/" title="JavaScript">JavaScript<sup>40</sup></a></li>
		  
		
		  
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/MongoDB/" title="MongoDB">MongoDB<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Mysql/" title="Mysql">Mysql<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Python/" title="Python">Python<sup>13</sup></a></li>
		  
		
		  
			<li><a href="/categories/Regex/" title="Regex">Regex<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/VisualStudio2017/" title="VisualStudio2017">VisualStudio2017<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Vmware/" title="Vmware">Vmware<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Wpf/" title="Wpf">Wpf<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/css/" title="css">css<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/前端框架/" title="前端框架">前端框架<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>2</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/JavaScript/" title="JavaScript">JavaScript<sup>40</sup></a></li>
			
		
			
				<li><a href="/tags/Python-django/" title="Python django">Python django<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/Html/" title="Html">Html<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Python/" title="Python">Python<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/NET-Core简易入门/" title=".NET Core简易入门">.NET Core简易入门<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C#">C#<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Mysql/" title="Mysql">Mysql<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Git/" title="Git">Git<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/DevExpress/" title="DevExpress">DevExpress<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Css/" title="Css">Css<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Docker/" title="Docker">Docker<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Vue/" title="Vue">Vue<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Html5/" title="Html5">Html5<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/包管理/" title="包管理">包管理<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/模块化/" title="模块化">模块化<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/JQuery/" title="JQuery">JQuery<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/MongoDB/" title="MongoDB">MongoDB<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/NET-FrameWork基础知识/" title=".NET FrameWork基础知识">.NET FrameWork基础知识<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/VisualStudio2017/" title="VisualStudio2017">VisualStudio2017<sup>1</sup></a></li>
			
		
		</ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer">
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,110laile. <br>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2020 
		
		<a href="/about" target="_blank" title="110laile">110laile</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>











<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
